---
title: "README_functions_TAPE"
author: "Stevan Paunoivc"
date: "2023-08-16"
output: PDF_document
---

# functions of the TAPE calculating tool

## Table of contents

-   Introduction

-   Function explanation

    -   Diversity

    -   Synergies

    -   Efficiency

    -   Recycling

    -   Resilience

    -   Culture and Food traditions

    -   Co-creation

    -   Human and social values

    -   Circular and Solidarity Economy

    -   Responsable Governance

    -   **CAET**

    -   Dietary Diversity

    -   Soil Health

    -   Secure and Land Tenure

    -   Woman Empowerment

    -   Youth Employment and Emigration

    -   Agricultural Biodiversity

    -   Exposure to Pesticides

    -   Productivity

    -   Income

    -   Food expenses

    -   added Value

    -   **TAPE**

-   Contributing

-   Contact

### Introduction

The FAO and a large number of partners have developed the Tool for Agroecological performance Evaluation (**TAPE**) to provide data on household, community and territorial scale while measuring the performance of farms across the different dimensions of sustainability. This R script provides functions for calculating the different parameters (CAET score, Dietary Diversity, Soil Health, Secure and Land Tenure, Woman Empowerment, Youth Employment Opportunities, Agricultural Biodiversity, Exposure to Pesticides, Productivity, Income and Added Value) and one for summarizing all of the results in one data frame. The calculations were adapted according to the new Tape methodology 2023.

### variable **key**

The variable **key** corresponds to the number the farm was given in the survey. It is used for mapping the data and ordering the newly calculated factors to the right farm. Every function will incorporate the **key** variable for the sake of properly ordering it in the final data frame.

#### Diversity

The Diversity score is calculated by the sum of the amount of **cultivated crops**[score 0-4], amount of **tree species** [score 0-4], amount of **animal species** [score 0-4] and amount of **income producing activities** (div_activ) score [0-4]. this sum is then divided by 16 and multiplied by 100.

```{r}
caet_diversity <- function(){
  Diversity <- data[,c('key', 'crops', 'animals', 'trees', 'div_activ')]
  Diversity <- Diversity %>%
    rowwise() %>%  #cleans data so there only is one number for crops animals trees ...
    mutate(div_sum = sum(c(crops, animals, trees, div_activ), na.rm = TRUE),
           div_aver = mean(c(crops ,animals ,trees ,div_activ),na.rm = TRUE),  # Is later used for Resilience
           div_score = round((div_sum/16)*100,6)) # calculates score
  return(Diversity)
  }

```

### Synergies

The Synergy score is calculated by the sum of the **crop-animal-integration** (cla_int) score [0-4], the **soil-plant-management** score [0-4], the **integration of trees** [score 0-4] and a score for the **connectivity of the farm to the landscape** [0-4]. This sum is then divided by 16 and multiplied by 100.

```{r}
caet_synergies <- function(){
  Synergies <- data[,c('key', 'cla_int', 's_plant', 'tree_int', 'connectivity')]
  Synergies <- Synergies %>% #creates dataframe to calculate indicator
    rowwise() %>%
    mutate(syn_sum = sum(c(cla_int ,s_plant ,tree_int ,connectivity),na.rm = TRUE),
           syn_score = round((syn_sum/16)*100,6))
  return(Synergies)
}
```

### Efficiency

The Efficiency score is calculated by the sum of the **use of external inputs** [score 0-4], **Management of soil fertility** [score 0-4], **Management of pests and diseases** [score 0-4] and by a score of e**merging efficiency from good practices** [score 0-4]. This sum is the divided by 16 and multiplied by 100.

```{r}
caet_efficiency <- function(){
  Efficiency <- data[,c('key', 'ext_inp', 'soil_fert', 'pest_dis', 'emergingefficiency')]
  Efficiency <- Efficiency %>%
    rowwise() %>%
    mutate(eff_sum = sum(c(ext_inp, soil_fert, pest_dis, emergingefficiency), na.rm = TRUE),
           eff_score = round((eff_sum/16)*100,6))
  return(Efficiency)
}
```

### Recycling

The Recycling score is calculated by the sum of **recycled biomass** [score 0-4], the **waste production and management** score [0-4], the **water recycling & saving** score [0-4], and **energy reduction and** **renewable energy** score [0-4]. This sum is then divided by 16 and multiplied by 100.

```{r}
caet_recycling <- function(){
  Recycling <- data[,c('key', 'rec_biomass', 'waste', 'water', 'ren_energy')]
  Recycling <- Recycling %>%
    rowwise() %>%
    mutate(rec_sum = sum(c(rec_biomass, waste, water, ren_energy),na.rm = TRUE),
           rec_score = round((rec_sum/16)*100,6))
  return(Recycling)
}
```

### Resilience

The Resilience score is calculated by the sum of **Existence of social mechanisms to reduce vulnerability** (vuln) [score 0-4], the **Environmental resilience and capacity to adapt to climate change** (indebt) [score 0-4], the mean of the 4 diversity (div_aver) scores, and the average score of the **indices measuring self-sufficiency and empowerment** (aver_suss_emp). The sum is then divided by 16 and multiplied by 100.

```{r}
caet_resilience <- function(){
  Resilience <- data[,c('key', 'crops', 'animals', 'trees', 'div_activ', 'ext_inp', 'seeds_breeds', 'local_fs', 'prod_empow', 'vuln', 'indebt')]
  Resilience <- Resilience %>%
    rowwise() %>%
    mutate(div_aver = mean(c(crops, animals, trees, div_activ), na.rm = TRUE), # emerging resilience from diversity
           aver_suff_emp = mean(c(ext_inp, seeds_breeds, local_fs, prod_empow), na.rm = T), # average score of the indices measuring self-sufficiency and empowerment
           res_sum = sum(c(vuln, indebt, div_aver, aver_suff_emp), na.rm = TRUE),
           res_score = round((res_sum/16)*100,6))
  return(Resilience)
}
```

### Culture and food traditions

The Culture and food traditions score is calculated by the sum of a score for **nutritional diet** (diet) [score 0-4], the score for **food self-sufficiency** (food_self_suff) [score 0-4], the **Local and traditional food heritage** (food_heritage) [score 0-4] and the **management of seeds and breeds** (seeds_breeds) [score 0-4]. The sum is then divided by 16 and multiplied by 100.

```{r}
caet_culture <- function(){
  Culture <- data[,c('key', 'diet', 'food_self_suff', 'food_heritage', 'seeds_breeds')]
  Culture <- Culture %>%
    rowwise() %>%
    mutate(cultf_sum = sum(c(diet, food_self_suff, food_heritage, seeds_breeds),na.rm = TRUE),
           cultf_score = round((cultf_sum/16)*100,6))
  return(Culture)
}
```

### Co-creation

The Co-creation score is calculated by the sum of the **availability of social platforms for knowledge transfer** (platforms)[score 0-4], **access and interest to agroecological knowledge** (ae_know) [score 0-4] and the **interconnection of producers to their community and grassroot networks** (partic_orgs) [score 0-4]. This sum is then divided by 12 and multiplied by 100.

```{r}
caet_cocreation <- function(){
  Cocreation <- data[,c('key', 'platforms', 'ae_know', 'partic_orgs')]
  Cocreation <- Cocreation %>%
    rowwise() %>%
    mutate(cocr_sum = sum(c(platforms, ae_know, partic_orgs),na.rm = TRUE),
           cocr_score = round((cocr_sum/12)*100,6))
  return(Cocreation)
}
```

### Human and social values

The score for human and social values is calculated by the sum of the **women empowerment** (women) score [0-4], a score that measures **working conditions, wages and family participation** (labour) [score 0-4], a score of weather the **youth wants to continue farming** (youth) [0-4] and a **animal welfare** (animalwel) score [0-4]. Then the sum is divided by 16 (or 12 if there are no animals on the farm) and multiplied by 100.

```{r}
caet_humanvalues <- function(){
  Humanvalues <- data[,c('key', 'women', 'labour', 'youth', 'animalwel')]
  Humanvalues <- Humanvalues %>%
    rowwise() %>%
    mutate(human_sum = sum(c(women, labour, youth, animalwel),na.rm = TRUE),
           human_score = round((human_sum/16)*100,6),
           human_score = ifelse(is.na(animalwel),round((human_sum/12)*100,6),human_score))
  return(Humanvalues)
}

```

### Circular economy and solidarity

The score for circular economy and solidarity is calculated by the sum of a score for **local marketing** (mkt_local) [score 0-4], **relationship with the consumers** (networks) [score 0-4] and and a score for the **local food system** (local_fs) [score 0-4]. The sum is then divided by 12 and multiplied by 100.

```{r}
caet_circular <- function(){
  Circular <- data[,c('key', 'mkt_local', 'networks', 'local_fs')]
  Circular <- Circular %>%
    rowwise() %>%
    mutate(circ_sum = sum(c(mkt_local, networks, local_fs),na.rm = TRUE),
           circ_score = round((circ_sum/12)*100,6))
  return(Circular)
}
```

### Responsible Governance

The score for responsible governance is calculated by the sum of the **producers rights and bargaining power** [score 0-4], **the cooperation between producers** [score 0-4] and the **possibility to participate in land governance** [score 0-4]. The sum is then divided by 12 and multiplied by 100.

```{r}
caet_governance <- function(){
  Governance <- data[,c('key', 'prod_empow', 'prod_orgs', 'partic_prod')]
  Governance <- Governance %>%
    rowwise() %>%
    mutate(respg_sum = sum(c(prod_empow, prod_orgs, partic_prod),na.rm = TRUE),
           respg_score = round((respg_sum/12)*100,6))
  return(Governance)
}
```

### Caracterisation of Agroecological Transition (CAET)

To calculate the Characterization of agroecological transition (CAET) the mean score of all the above calculated scores (Diversity, Synergies, Efficiency, Recycling, Resilience, Culture and food traditions, Co-creation, Human and social values and Responsible Governance) is calculated.

```{r}
caet_CAET <- function(){
  
  Diversity <- caet_diversity()
  Synergies <- caet_synergies()
  Efficiency <- caet_efficiency()
  Recycling <- caet_recycling()
  Resilience <- caet_resilience()
  Culture <- caet_culture()
  Cocreation <- caet_cocreation()
  Humanvalues <- caet_humanvalues()
  Circular <- caet_circular()
  Governance <- caet_governance()
  
  CAET <- Diversity %>%
    select(key, div_score) %>%
    left_join(Synergies[,c('key', 'syn_score')], by = 'key') %>%
    left_join(Efficiency[,c('key', 'eff_score')], by = 'key') %>%
    left_join(Recycling[,c('key', 'rec_score')], by = 'key') %>%
    left_join(Resilience[,c('key', 'res_score')], by = 'key') %>%
    left_join(Culture[,c('key', 'cultf_score')], by = 'key') %>%
    left_join(Cocreation[,c('key', 'cocr_score')], by = 'key') %>%
    left_join(Humanvalues[,c('key', 'human_score')], by = 'key') %>%
    left_join(Circular[,c('key', 'circ_score')], by = 'key') %>%
    left_join(Governance[,c('key', 'respg_score')], by = 'key') %>%
    mutate(caet_tot = mean(c(div_score,syn_score,eff_score,rec_score,res_score,cultf_score,cocr_score,human_score,circ_score,respg_score), na.rm = TRUE))
  
  return(CAET)
}
```

### Dietary Diversity

The columns loaded in to the new data frame **DietaryDiv** contain the value of 1 or 0 for the answers "yes" and "no" of the survey. The values are given ans seen in the following table:

| Food                                                                                                                 | Value |
|----------------------------------------------------------------------------------------------------------------------|-------|
| Foods made from grains - Sorghum, millet, corn, couscous, barley, rice, pasta, noodles, etc. (grains_a)              | 1     |
| White roots and tubers or plantains - White potatoes, white yams, Cassava, cocoyam, taro, plantains, etc. (grains_b) | 1     |
| Pulses - Beans, peas, fresh or dried seed, lentils, beans, peas, hummus, tofu, etc. (pulses)                         | 1     |
| Nuts and seeds - Tree nut, groundnut/peanut or certain seeds, or nut/seeds "butters" or pastes (nuts)                | 1     |
| Milk (dairy_e)                                                                                                       | 1     |
| Cheese or yoghurt (dairy_f)                                                                                          | 1     |
| Organ meats - blood sausage, gizzard, heart, kidney, liver (meat_h)                                                  | 1     |
| Red flesh meat from mammals - beef, goat, lamb, mutton, pork, rabbit, yak (meat_i)                                   | 1     |
| Processed meat - salami, bacon, bologna, hot dogs (meat_j)                                                           | 1     |
| Poultry and other white meats (meat_k)                                                                               | 1     |
| Fish and seafood (meat_l)                                                                                            | 1     |
| Eggs (eggs)                                                                                                          | 1     |
| Dark green leafy vegetables (darkgreen)                                                                              | 1     |
| Dark yellow or orange vegetables - pumpkin, carrots, squash or sweet potatoes (darkyellow_n)                         | 1     |
| any other vegetables (otherveg)                                                                                      | 1     |
| Dark yellow or orange fruits (darkyellow_o)                                                                          | 1     |
| any other Fruits (otherfruit)                                                                                        | 1     |

Other food groups inlcude fried and salty food, deep fried foods, salty snacks, instant noodles, fast food restaurant foods, sweet foods, sugar-sweetened beverages and sweetened infusions and are not directly included in the dietary diversity score. These values are added to each other and multiplied by 10.

```{r}
step2_Dietary_Diversity <- function(){
  DietaryDiv <- data[,c('key', 'grains_a', 'grains_b', 'pulses', 'nuts', 'dairy_e', 'dairy_f', 'meat_h', 'meat_i', 'meat_j', 'meat_k', 'meat_l',
                        'eggs', 'darkgreen', 'darkyellow_n', 'darkyellow_o', 'otherveg', 'otherfruit', 'fried_salty_1', 'fried_salty_2', 'fried_salty_3', 'fried_salty_4',
                        'sweet_foods', 'sweet_beverages_1', 'sweet_beverages_2')]
  DietaryDiv <- DietaryDiv %>%
    rowwise() %>%
    mutate(grains = ifelse(grains_a == 1 | grains_b == 1, 1, 0),
           dairy = ifelse(dairy_e == 1 | dairy_f == 1, 1, 0),
           meat = ifelse(meat_h == 1 | meat_i == 1 | meat_j == 1 | meat_k == 1 | meat_l == 1, 1, 0),
           darkyellow = ifelse(darkyellow_n == 1 | darkyellow_o == 1, 1, 0),
           fried_salty = ifelse(fried_salty_1 == 1 | fried_salty_2 == 1 | fried_salty_3 == 1 | fried_salty_4 == 1, 1, 0), # is not included for dietary diversity score, get's calculated anyways.
           sweet_beverages = ifelse(sweet_beverages_1 == 1 |  sweet_beverages_2 == 1, 1, 0)) %>% # is not included for dietary diversity score, get's calculated anyways.
    rowwise() %>%
    mutate(dietary_diversity = sum(c(grains, pulses, nuts, dairy, meat, eggs, darkgreen, darkyellow, otherveg, otherfruit), na.rm = T)) %>%
    mutate(dietary_diversity = dietary_diversity*10) %>%
    mutate(dietary_diversity = ifelse(is.na(dietary_diversity), 0, dietary_diversity)) %>%
    return(DietaryDiv)
}
```

###Soil Health

The listed characteristics of soil health have a score of 1-5. The mean of all the categories is taken. This score is translated to a scale of 0-100.

```{r}
step2_SoilHealth <- function(){
  SoilHealth <- data[,c('key', 'structure', 'compaction', 'depth', 'residues', 'color', 'water_ret', 'cover', 'erosion', 'invertebrates', 'microbio')]
  SoilHealth <- SoilHealth %>%
    rowwise() %>%
    mutate(soil_health = mean(c(structure,compaction,depth,residues,color,water_ret,cover,erosion,invertebrates,microbio),na.rm = T)) %>%
    mutate(soil_health = (soil_health - 1) * 25)
  return(SoilHealth)
}

```

### Secure Land Tenure

The land tenure score is driven by whether farmers have legal recognition of the farm (**recland**\_), whether they have a formal document (**doc**\_), if their name is listed as owner (name\_), if they perceive the access to the land as secure (**ltperc**\_), and whether they have the right to sell, bequeath or inherit the land (**sell\_,beq\_, inh\_**). The scores were given as seen in the following table:

| Legal recognition | Name on document | Perceive access is secure | Sell/bequeath/inherit | landtenure_score |
|-------------------|------------------|---------------------------|-----------------------|------------------|
| 1                 | 1                | 1                         | \>0                   | 100              |
| 1                 | 0                | \-                        | \-                    | 50               |
| 1                 | 1                | 0                         | \-                    | 50               |
| 0                 | \-               | 1                         | \>0                   | 50               |
| 0                 | \-               | 0                         | \-                    | 0                |
| 0                 | \-               | \-                        | 0                     | 0                |

We calculated the average of the two and scaled the values from 1-3 points to 0-100%.

```{r}
step2_LandTenure <- function(){
  Landtenure <- data[,c('key', 'recland_men', 'doc_men', 'doc_menoth', 'name_men', 'ltperc_men', 'sell_men', 'beq_men', 'inh_men', 'recland_women', 'doc_women', 'doc_womenoth', 'name_women', 'ltperc_women', 'sell_women', 'beq_women', 'inh_women')]
  
  Landtenure <- Landtenure %>%
    rowwise() %>%
    mutate(tmp_men = sum(c(sell_men, beq_men, inh_men), na.rm = T)) %>%
    mutate(landtenure_men = 0) %>%
    mutate(landtenure_men = case_when(recland_men == 1 & name_men == 1 & ltperc_men == 1 & tmp_men > 0 ~ 100,
                                      recland_men == 1 & name_men == 0 ~ 50,
                                      recland_men == 0 & ltperc_men == 1 & tmp_men > 0 ~ 50,
                                      recland_men == 1 & name_men == 1 & ltperc_men == 0 ~ 50,
                                      recland_men == 1 & name_men == 1 & ltperc_men != 1 & tmp_men > 0 ~ 50,
                                      recland_men == 0 & ltperc_men == 0 ~ 0,
                                      recland_men == 0 & tmp_men == 0 ~ 0)) %>%
    rowwise() %>%
    mutate(tmp_women = sum(c(sell_women, beq_women, inh_women), na.rm = T)) %>%
    mutate(landtenure_women = 0) %>%
    mutate(landtenure_women = case_when(recland_women == 1 & name_women == 1 & ltperc_women == 1 & tmp_women > 0 ~ 100,
                                        recland_women == 1 & name_women == 0 ~ 50,
                                        recland_women == 0 & ltperc_women == 1 & tmp_women > 0 ~ 50,
                                        recland_women == 1 & name_women == 1 & ltperc_women == 0 ~ 50,
                                        recland_women == 1 & name_women == 1 & ltperc_women != 1 & tmp_women > 0 ~ 50,
                                        recland_women == 0 & ltperc_women == 0 ~ 0,
                                        recland_women == 0 & tmp_women == 0 ~ 0))
  Landtenure <- Landtenure %>%
    mutate(landtenure = mean(c(landtenure_women, landtenure_men), na.rm = T))
  
  return(Landtenure)
}
```

### Womens Empowerment score

The Womens empowerment score is calculated by the mean of the following domains: Productive Decision, Decision Making, Income Use, Leadership and Time use. These domains have subdomains and will be written in **bold**. Additionally to the Womens empowerment score the Mens empowerment score is calculated. These variables will have the same name just with a \*\* *men*\*\* inserted. The calculations are usually the same as for the womens empowerment score and will only be mentioned if they differ. **Productive decision** is defined by the mean of the following subdomains: Decisions about crops, animals & economic activities, Decisions for household expenditures. It is dependent on questions with two possible answer sets with the corresponding values shown in the tables below.

| answers                         | value |
|---------------------------------|-------|
| Completely the man              | 1     |
| Mostly the man                  | 2     |
| Both man and woman              | 3     |
| Mostly the woman                | 4     |
| Completely the woman            | 5     |
| Someone else outside the family | 6     |
| Not applicable                  | 7     |

"Not applicable" can be ignored as it is transformed to NA values.

For decisions about crop production (decrop), animal production (decanim) & other economic activities (decotact) new variables are created (prodec_c, prodec_a, prodec_oa) that assign the answers a score between 0 and 1. The same is done for decisions about major (decmajor) expenditures. After that the mean is taken for animal production, crop production and economic activities.

```{r}
 ProductiveDecision <- data[, c('key', 'deccrop', 'decanim', 'decotact', # About crops, animals, and other economic activities
                                 'decmajor')] # About Major and minor hh expenditures (codifico e poi media)
                    
  # 2.4.1 Decisions about crops, animals and other economic activities
  ProductiveDecision <- ProductiveDecision %>%
    mutate(prodec_wom_c = case_when(deccrop %in% c(1,6) ~ 0, # completely the man & someone else outside the family
                                    deccrop == 2 ~ 0.25, # mostly the man
                                    deccrop == 3 ~ 0.5, # both man and woman
                                    deccrop == 4 ~ 0.75, # mostly the woman
                                    deccrop == 5 ~ 1, # completely the woman
                                    deccrop == 7 ~ NA), 
           prodec_wom_a = case_when(decanim %in% c(1,6) ~ 0, # completely the man & someone else outside the family
                                    decanim == 2 ~ 0.25, # mostly the man
                                    decanim == 3 ~ 0.5, # both man and woman
                                    decanim == 4 ~ 0.75, # mostly the woman
                                    decanim == 5 ~ 1, # completely the woman
                                    decanim == 7 ~ NA), 
           prodec_wom_oa = case_when(decotact %in% c(1,6) ~ 0, # completely the man & someone else outside the family
                                     decotact == 2 ~ 0.25, # mostly the man
                                     decotact == 3 ~ 0.5, # both man and woman
                                     decotact == 4 ~ 0.75, # mostly the woman
                                     decotact == 5 ~ 1, # completely the woman
                                     decotact == 7 ~ NA),
           # For Men-Index
           prodec_men_c = case_when(deccrop == 1 ~ 1, # completely the man
                                    deccrop == 2 ~ 0.75, # mostly the man
                                    deccrop == 3 ~ 0.5, # both man and woman
                                    deccrop == 4 ~ 0.25, # mostly the woman
                                    deccrop %in% c(5,6) ~ 0, # completely the woman & someone else outside the family
                                    deccrop == 7 ~ NA), 
           prodec_men_a = case_when(decanim == 1 ~ 1, # completely the man
                                    decanim == 2 ~ 0.75, # mostly the man
                                    decanim == 3 ~ 0.5, # both man and woman
                                    decanim == 4 ~ 0.25, # mostly the woman
                                    decanim %in% c(5,6) ~ 0, # completely the woman & someone else outside the family
                                    decanim == 7 ~ NA),
           prodec_men_oa = case_when(decotact == 1 ~ 1, # completely the man
                                     decotact == 2 ~ 0.75, # mostly the man
                                     decotact == 3 ~ 0.5, # both man and woman
                                     decotact == 4 ~ 0.25, # mostly the woman
                                     decotact %in% c(5,6) ~ 0, # completely the woman & someone else outside the family
                                     decotact == 7 ~ NA)) %>%
    rowwise() %>%
    mutate(prodec_wom_caoa = mean(c(prodec_wom_c, prodec_wom_a, prodec_wom_oa), na.rm = T)) %>%
    rowwise() %>%
    mutate(prodec_men_caoa = mean(c(prodec_men_c, prodec_men_a, prodec_men_oa), na.rm = T)) # For Men Index
  
  # Decisions household expenditures
  ProductiveDecision <- ProductiveDecision %>%
    mutate(prodec_wom_maj = case_when(decmajor %in% c(1,6) ~ 0, # completely the man & someone else outside the family
                                      decmajor == 2 ~ 0.25, # mostly the man
                                      decmajor == 3 ~ 0.5, # both man and woman
                                      decmajor == 4 ~ 0.75, # mostly the woman
                                      decmajor == 5 ~ 1, # completely the woman
                                      decmajor == 7 ~ NA),
           # For Men-Index
           prodec_men_maj = case_when(decmajor == 1 ~ 1, # completely the man
                                      decmajor == 2 ~ 0.75, # mostly the man
                                      decmajor == 3 ~ 0.5, # both man and woman
                                      decmajor == 4 ~ 0.25, # mostly the woman
                                      decmajor %in% c(5,6) ~ 0, # completely the woman & someone else outside the family
                                      decmajor == 7 ~ NA)) %>%
    # Total Productive Decisions score:
    rowwise() %>%
    mutate(prodec_wom = mean(c(prodec_wom_caoa, prodec_wom_maj), na.rm = TRUE)) %>% #Total Productive Decisions score for Women
    rowwise() %>%
    mutate(prodec_men = mean(c(prodec_men_caoa, prodec_men_maj), na.rm = TRUE)) # Total Productive Decision score for Men
  
  ProductiveDecision <- rapply(ProductiveDecision, f = function(x) ifelse(is.nan(x), NA, x), how = "replace" )
```

The **Decision Making** score is calculated by the mean of the subdomains: Land tenure score, Credit score, Ownership score for Crops animals and assets and the Ownership score for household assets. Possible answers were assigned with the following numbers:

| answers                                                    | score |
|------------------------------------------------------------|-------|
| Possible in official and secure channels (bank or similar) | 1     |
| Possible in non-official channels                          | 2     |
| Not possible. Access to credit is too hard or too risky    | 3     |

To calculate the land tenure score we simply call the function "step2_LandTenure()", and choose the variables for men and women.

```{r}
## 2.4.2 Acces To and decision-making power over productive resources
  
  DecisionMaking <- data[,c('key', 'credit_women', 'credit_men',
                            'owcrop', 'owanim', 'owotact', 'owhouse')]
  
  Landtenure <- step2_LandTenure()
  
  DecisionMaking <- DecisionMaking %>%
    left_join(Landtenure[,c('key', 'landtenure_women', 'landtenure_men')], by = 'key') %>%
    mutate(landtenure_women = landtenure_women * 0.01) %>%
    mutate(landtenure_men = landtenure_men * 0.01)
  

```

The credit score is calculated as shown in the following table.

| Women                 | Men                   | Score |
|-----------------------|-----------------------|-------|
| Official channels     | \-                    | 1     |
| Non-official channels | Not possible          | 0.8   |
| Non-official channels | Non-official channels | 0.75  |
| Non-official channels | Official channels     | 0.5   |
| Not possible          | Not possible          | 0.25  |
| Not possible          | Non-official channels | 0.1   |
| Not possible          | Official channels     | 0     |
| Non-official channels | NA                    | 0.5   |

```{r}
 # Access to credit
  DecisionMaking <- DecisionMaking %>%
    mutate(credit_score_wom = case_when(credit_women == 1 ~ 1,
                                        credit_women == 2 & credit_men == 3 ~ 0.8,
                                        credit_women == 2 & credit_men == 2 ~ 0.75,
                                        credit_women == 2 & credit_men == 1 ~ 0.5,
                                        credit_women == 3 & credit_men == 3 ~ 0.25,
                                        credit_women == 3 & credit_men == 2 ~ 0.1,
                                        credit_women == 3 & credit_men == 1 ~ 0,
                                        credit_women == 2 & is.na(credit_men) ~ 0.5,
                                        credit_women == 3 & is.na(credit_men) ~ 0)) %>%
    # For Men-Index
    mutate(credit_score_men = case_when(credit_men == 1 ~ 1,
                                        credit_men == 2 & credit_women == 3 ~ 0.8,
                                        credit_men == 2 & credit_women == 2 ~ 0.75,
                                        credit_men == 2 & credit_women == 1 ~ 0.5,
                                        credit_men == 3 & credit_women == 3 ~ 0.25,
                                        credit_men == 3 & credit_women == 2 ~ 0.1,
                                        credit_men == 3 & credit_women == 1 ~ 0,
                                        credit_men == 2 & is.na(credit_women) ~ 0.5,
                                        credit_men == 3 & is.na(credit_women) ~ 0))
```

The Subdomain Ownership asks about Ownership of crops (owcrop), animals (owanim) & economic assets (owtact) and for household assets (owhouse). The possible answers are the same as in the Productive Decision chapter and it is also calculated the same way.

```{r}
 # ownership of crops, animals, other activities
  DecisionMaking <- DecisionMaking %>%
    mutate(own_wom_c = case_when(owcrop %in% c(1,6) ~ 0, # completely the man & someone else outside the family
                                 owcrop == 2 ~ 0.25, # mostly the man
                                 owcrop == 3 ~ 0.5, # both man and woman
                                 owcrop == 4 ~ 0.75, # mostly the woman
                                 owcrop == 5 ~ 1, # completely the woman
                                 owcrop == 7 ~ NA),
           own_wom_a = case_when(owanim %in% c(1,6) ~ 0, # completely the man & someone else outside the family
                                 owanim == 2 ~ 0.25, # mostly the man
                                 owanim == 3 ~ 0.5, # both man and woman
                                 owanim == 4 ~ 0.75, # mostly the woman
                                 owanim == 5 ~ 1, # completely the woman
                                 owanim == 7 ~ NA),
           own_wom_oa = case_when(owotact %in% c(1,6) ~ 0, # completely the man & someone else outside the family
                                  owotact == 2 ~ 0.25, # mostly the man
                                  owotact == 3 ~ 0.5, # both man and woman
                                  owotact == 4 ~ 0.75, # mostly the woman
                                  owotact == 5 ~ 1, # completely the woman
                                  owotact == 7 ~ NA)) %>%
    # For Men-Index
    mutate(own_men_c = case_when(owcrop == 1 ~ 1, # completely the man
                                 owcrop == 2 ~ 0.75, # mostly the man
                                 owcrop == 3 ~ 0.5, # both man and woman
                                 owcrop == 4 ~ 0.25, # mostly the woman
                                 owcrop %in% c(5,6) ~ 0, # completely the woman & someone else outside the family
                                 owcrop == 7 ~ NA),
           own_men_a = case_when(owanim == 1 ~ 1, # completely the man
                                 owanim == 2 ~ 0.75, # mostly the man
                                 owanim == 3 ~ 0.5, # both man and woman
                                 owanim == 4 ~ 0.25, # mostly the woman
                                 owanim %in% c(5,6) ~ 0, # completely the woman & someone else outside the family
                                 owanim == 7 ~ NA),
           own_men_oa = case_when(owotact == 1 ~ 1, # completely the man
                                  owotact == 2 ~ 0.75, # mostly the man
                                  owotact == 3 ~ 0.5, # both man and woman
                                  owotact == 4 ~ 0.25, # mostly the woman
                                  owotact %in% c(5,6) ~ 0, # completely the woman & someone else outside the family
                                  owotact == 7 ~ NA)) %>%
    rowwise() %>%
    mutate(own_wom_caoa = mean(c(own_wom_c, own_wom_a, own_wom_oa), na.rm = T)) %>%
    rowwise() %>%
    mutate(own_men_caoa = mean(c(own_men_c, own_men_a, own_men_oa), na.rm = T))
  
  # Ownership of major & minor hh assets
  DecisionMaking <- DecisionMaking %>%
    mutate(own_wom_maj = case_when(owhouse %in% c(1,6) ~ 0, # completely the man & someone else outside the family
                                   owhouse == 2 ~ 0.25, # mostly the man
                                   owhouse == 3 ~ 0.5, # both man and woman
                                   owhouse == 4 ~ 0.75, # mostly the woman
                                   owhouse == 5 ~ 1, # completely the woman
                                   owhouse == 7 ~ NA)) %>%
    # For Men-Index
    mutate(own_men_maj = case_when(owhouse == 1 ~ 1, # completely the man
                                   owhouse == 2 ~ 0.75, # mostly the man
                                   owhouse == 3 ~ 0.5, # both man and woman
                                   owhouse == 4 ~ 0.25, # mostly the woman
                                   owhouse %in% c(5,6) ~ 0, # completely the woman & someone else outside the family
                                   owhouse == 7 ~ NA))

```

The total **decision making** score (cred_decmak_women) is calculated by the mean of all subdomains.

```{r}
  # Total Access To and Decision-Making score
  DecisionMaking <- DecisionMaking %>%
    rowwise() %>%
    mutate(cred_decmak_wom = mean(c(landtenure_women, credit_score_wom, own_wom_caoa, own_wom_maj), na.rm = T)) %>%
    rowwise() %>%
    mutate(cred_decmak_men = mean(c(landtenure_men, credit_score_men, own_men_caoa, own_men_maj), na.rm = T))
  DecisionMaking <- rapply(DecisionMaking, f = function(x) ifelse(is.nan(x), NA, x), how = "replace" )
```

The Domain **Income Use** is calculated the same as Ownership or Productive Decision. With dec_rev_crop being the variable for decisions about income use generated by crops, dec_rev_anim by animals and dec_rev_oth by other economic activities. The final variable for **Income Use** is named decinc_women.

```{r}
## 2.4.3 Use of Income
  IncomeUse <- data[, c('key', 'dec_rev_crop', 'dec_rev_anim', 'dec_rev_oth')] 
  
  IncomeUse <- IncomeUse %>%
    mutate(decinc_wom_c = case_when(dec_rev_crop %in% c(1,6) ~ 0, # completely the man & someone else outside the family
                                    dec_rev_crop == 2 ~ 0.25, # mostly the man
                                    dec_rev_crop == 3 ~ 0.5, # both man and woman
                                    dec_rev_crop == 4 ~ 0.75, # mostly the woman
                                    dec_rev_crop == 5 ~ 1, # completely the woman
                                    dec_rev_crop == 7 ~ NA), 
           decinc_wom_a = case_when(dec_rev_anim %in% c(1,6) ~ 0, # completely the man & someone else outside the family
                                    dec_rev_anim == 2 ~ 0.25, # mostly the man
                                    dec_rev_anim == 3 ~ 0.5, # both man and woman
                                    dec_rev_anim == 4 ~ 0.75, # mostly the woman
                                    dec_rev_anim == 5 ~ 1, # completely the woman
                                    dec_rev_anim == 7 ~ NA), 
           decinc_wom_oa = case_when(dec_rev_oth %in% c(1,6) ~ 0, # completely the man & someone else outside the family
                                     dec_rev_oth == 2 ~ 0.25, # mostly the man
                                     dec_rev_oth == 3 ~ 0.5, # both man and woman
                                     dec_rev_oth == 4 ~ 0.75, # mostly the woman
                                     dec_rev_oth == 5 ~ 1, # completely the woman
                                     dec_rev_oth == 7 ~ NA)) %>%
    # For Men-Index
    mutate(decinc_men_c = case_when(dec_rev_crop == 1 ~ 1, # completely the man
                                    dec_rev_crop == 2 ~ 0.75, # mostly the man
                                    dec_rev_crop == 3 ~ 0.5, # both man and woman
                                    dec_rev_crop == 4 ~ 0.25, # mostly the woman
                                    dec_rev_crop %in% c(5,6) ~ 0, # completely the woman & someone else outside the family
                                    dec_rev_crop == 7 ~ NA), 
           decinc_men_a = case_when(dec_rev_anim == 1 ~ 1, # completely the man
                                    dec_rev_anim == 2 ~ 0.75, # mostly the man
                                    dec_rev_anim == 3 ~ 0.5, # both man and woman
                                    dec_rev_anim == 4 ~ 0.25, # mostly the woman
                                    dec_rev_anim %in% c(5,6) ~ 0, # completely the woman & someone else outside the family
                                    dec_rev_anim == 7 ~ NA),
           decinc_men_oa = case_when(dec_rev_oth == 1 ~ 1, # completely the man
                                     dec_rev_oth == 2 ~ 0.75, # mostly the man
                                     dec_rev_oth == 3 ~ 0.5, # both man and woman
                                     dec_rev_oth == 4 ~ 0.25, # mostly the woman
                                     dec_rev_oth %in% c(5,6) ~ 0, # completely the woman & someone else outside the family
                                     dec_rev_oth == 7 ~ NA)) %>%
    rowwise() %>%
    mutate(decinc_wom = mean(c(decinc_wom_c, decinc_wom_a, decinc_wom_oa), na.rm = T)) %>%
    rowwise() %>%
    mutate(decinc_men = mean(c(decinc_men_c, decinc_men_a, decinc_men_oa), na.rm = T))
  IncomeUse <- rapply(IncomeUse, f = function(x) ifelse(is.nan(x), NA, x), how = "replace" )
```

For the **Leadership** we use the variables involv_agri_wom for involvement in agriculture related organisations and involv_othe_wom for involvement in other organisations. These have the following values assigned to them:

| answer                                                       | Score |
|--------------------------------------------------------------|-------|
| I do not participate in such organizations                   | 1     |
| I rarely participate in such meetings / organizations        | 2     |
| I participate often but rarely speak in the meetings         | 3     |
| I am an active member, sometimes speak in meetings           | 4     |
| I often speak in meetings, participate in decision processes | 5     |

The scores are then translated in to a scale from 0-1 ((score-1)\*0.25) and renamed to lead_wom_agri and lead_wom_othe. Finally the greater value of the two questions is taken as the **Leadership** score.

```{r}
 ## 2.4.4 Leadership in the community
  Leadership <- data[,c('key', 'involv_agri_wom', 'involv_othe_wom', 'involv_agri_men', 'involv_othe_men')]
  
  Leadership <- Leadership %>%
    mutate(lead_wom_agri = (involv_agri_wom - 1)*0.25,
           lead_wom_othe = (involv_othe_wom - 1)*0.25) %>%
    mutate(lead_men_agri = (involv_agri_men - 1)*0.25,
           lead_men_othe = (involv_othe_men - 1)*0.25) %>%
    rowwise() %>%
    mutate(leadership_score_wom = max(lead_wom_agri, lead_wom_othe, na.rm = T)) %>%
    rowwise() %>%
    mutate(leadership_score_men = max(lead_men_agri, lead_men_othe, na.rm = T))
  Leadership <- rapply(Leadership, f = function(x) ifelse(is.infinite(x), NA, x), how = "replace" )
  
```

For the calculating the **time use score** the sum of the working hours per day is calculated (tmp_wtime_women). It is the sum of the hours spent on agricultural production (wtime_ag_women), food preparation (wtime_dom_women) and other domestic works and other gainful activities (wtime_otgain_women). We assume that the total worktime (hrs_wom/hrs_men) per day is maximum 18 hours. If the total worktime exceeds 18 hours, the single worktimes spent for agriculture, domestic and other work gets reduced by a factor, that it totals in 18 hours work per day. The first parameter (hrs_women) is assigned the value of 1 if the sum of the working hours is lower than 10.5. Else it is 0. The second score (worktime_women) defines if the other gender works longer and is given a score of 1 if this is true and 0 if its not. The **time use score** (timeuse_women) is calculated by the average of the two scores.

```{r}
 ## 2.4.5 Time use (average between the two scores)
  Timeuse <- data[,c('key', 'wtime_ag_women', 'wtime_dom_women', 'wtime_otgain_women', 'wtime_ag_men', 'wtime_dom_men', 'wtime_otgain_men')]
  
  # set 18hrs/day of work as maximun and if surpassed reduce all activities accordingly
  Timeuse <- Timeuse %>%
    rowwise() %>%
    mutate(hrs_wom = sum(c(wtime_ag_women + wtime_dom_women + wtime_otgain_women), na.rm = T),
           hrs_men = sum(c(wtime_ag_men + wtime_dom_men + wtime_otgain_men), na.rm = T)) %>%
    # calculate shares (which are used if total hours > 18)
    mutate(wtime_ag_women_share = wtime_ag_women/hrs_wom,
           wtime_dom_women_share = wtime_dom_women/hrs_wom,
           wtime_otgain_women_share = wtime_otgain_women/hrs_wom,
           wtime_ag_men_share = wtime_ag_men/hrs_men,
           wtime_dom_men_share = wtime_ag_men/hrs_men,
           wtime_otgain_men_share = wtime_otgain_men/hrs_men) %>%
    # replace if hours > 18
    mutate(wtime_ag_women = ifelse(hrs_wom > 18, wtime_ag_women_share * 18, wtime_ag_women),
           wtime_dom_women = ifelse(hrs_wom > 18, wtime_dom_women_share * 18, wtime_dom_women),
           wtime_otgain_women = ifelse(hrs_wom > 18, wtime_otgain_women_share * 18, wtime_otgain_women),
           wtime_ag_men = ifelse(hrs_men > 18, wtime_ag_men_share * 18, wtime_ag_men),
           wtime_dom_men = ifelse(hrs_men > 18, wtime_dom_men_share * 18, wtime_dom_men),
           wtime_otgain_men = ifelse(hrs_men > 18, wtime_otgain_men_share * 18, wtime_otgain_men),
           hrs_wom = ifelse(hrs_wom > 18, 18, hrs_wom),
           hrs_men = ifelse(hrs_men > 18, 18, hrs_men))
  
  # Total Time Use score:
  Timeuse <- Timeuse %>%
    mutate(timeuse_wom = 0.133*(18-hrs_wom),
           timeuse_men = 0.133*(18-hrs_men)) %>%
    mutate(timeuse_wom = ifelse(timeuse_wom > 1, 1, timeuse_wom),
           timeuse_men = ifelse(timeuse_men > 1, 1, timeuse_men)) 

```

All the data is now put together to one dataframe called "WomenEmpowerment". The final Women's empowerment score (wemp_score) is calculated by the mean of all the calculated domains (same goes for the Men's empowerment score (memp_score)). The means are then multiplied by 100. If there are no women on the farm the Women's empowerment score is NA. Additionally, another score is created called **GPI (Gender Parity Index)**, where the Women's empowerment score is divided by the Men's empowerment score and then multiplied by 100.

```{r}
## 2.4.6 Total Women Empowerment Score (5DE = Five-dimension empowerment index)
WomenEmpowerment <- ProductiveDecision %>%
    select(c('key', 'prodec_wom', 'prodec_men')) %>%
    left_join(DecisionMaking[,c('key', 'cred_decmak_wom', 'cred_decmak_men')], by = 'key') %>%
    left_join(IncomeUse[,c('key', 'decinc_wom', 'decinc_men')], by = 'key') %>%
    left_join(Leadership[,c('key', 'leadership_score_wom', 'leadership_score_men')], by = 'key') %>%
    left_join(Timeuse[,c('key', 'timeuse_wom', 'timeuse_men')], by = 'key') %>%
    rowwise() %>%
    mutate(wemp_score = mean(c(prodec_wom, cred_decmak_wom, decinc_wom, leadership_score_wom, timeuse_wom), na.rm = T)*100) %>%
    rowwise() %>%
    mutate(memp_score = mean(c(prodec_men, cred_decmak_men, decinc_men, leadership_score_men, timeuse_men), na.rm = T)*100)
  WomenEmpowerment <- rapply(WomenEmpowerment, f = function(x) ifelse(is.nan(x), NA, x), how = "replace" )
  
  rm(ProductiveDecision, DecisionMaking, IncomeUse, Leadership, Timeuse)
  
  # Replace the result with missing value if there are no women in the household:
  WomenEmpowerment <- WomenEmpowerment %>% 
    left_join(data[,c('key', 'hh_fem' )], by = 'key') %>%
    mutate(wemp_score = ifelse(hh_fem == 0, NA, wemp_score))
  
  # implement GPI score (Gender Parity Index) & AWEAI score (Abbreviated Women's Empowerment in Agriculture Index)
  
  WomenEmpowerment <- WomenEmpowerment %>%
    mutate(GPI = wemp_score/memp_score * 100) %>%
    mutate(AWEAI = 0.9 * wemp_score + 0.1 * GPI)
  return(WomenEmpowerment)
```

### Youth employment and emigration

The youth score contains two sub-scores: Employment score and Emigration score. The youth score gets calculated first for all youth members of the farm (male and female) and in a second step it gets calculated by sex.

**y_occup** describes the occupation of the youngsters and contains the following values:

| Description                                                                                         | Value |
|-----------------------------------------------------------------------------------------------------|-------|
| Not working nor studying                                                                            | 0     |
| Working in the agricultural production within the system assessed                                   | 1     |
| Both working in the agricultural production within the system and also employed outside the system  | 2     |
| Employed outside the system assessed                                                                | 3     |
| Both working in the agricultural production within the system and also enrolled in formal education | 4     |
| Enrolled in formal education                                                                        | 5     |
| Works in his/her own farm                                                                           | 6     |

Three new columns are created called "y_good", "y_med", "y_bad" ordering the values of **y_occup**. For example "y_good" would receive a value of 1 in cases where **y_occup** had values of either 1,4,5 or 6 (and a 0 in all the other cases). After that of all the values of y_good within the same farm are defined as a new variable **good_sum**. The same is done for the other two categories. The percentage of youngsters is calculated for each category (good_perc, medium_perc and bad_perc). The youth employment score (**youth_employ**) is then defined by (**good_perc** + 0.5\* **med_perc)/1.5**.

For Emigration the two variables **y_future_farm** and **y_keen_emigr** describe whether the youngsters want to be a farmer in the future or emigrate. For either statement being true a 1 is assigned to the corresponding variable. Then the youngsters are assigned to 4 categories as seen in the following table:

| Description                                  | y_future_farm | y_keen_emigr | category |
|----------------------------------------------|---------------|--------------|----------|
| Would like to stay on the farm               | 1             | 0            | g1       |
| Would like to emigrate                       | 0             | 1            | g2       |
| Wants a farm but also would like to emigrate | 1             | 1            | g3       |
| Neither wants a farm nor to emigrate         | 0             | 0            | g4       |

For every farm the amount of youngsters for each category is defined as **gX_sum**. From this and **ymembers** we calculate the percentage of youngsters for every category (**gX_perc**). The emigration score (**youth_emigr**) is then calculated by (**g1_perc** + 0.5\* **g3_perc + 0.5 \*g4_perc**)/2.

The youth score (**youth_score**) is calculated as the mean of the employment (**youth_employ**) and emigration (**youth_emigr**). For systems without youngsters NA is defined as the value of **youth_score**.

```{r}
  # Male
  youth_emp_m <- data_Youth_Males %>%
    left_join(data[,c('key', 'hh_myoung', 'hh_fyoung')], by = 'key') %>%
    mutate(sex = 1) %>% # 1 for male
    rename(y_occup = y_occup_m,
           y_future_farm = y_future_farm_m, 
           y_keen_emigr = y_keen_emigr_m)
  
  # Female
  youth_emp_f <- data_Youth_Females %>%
    left_join(data[,c('key', 'hh_myoung', 'hh_fyoung')], by = 'key') %>%
    mutate(sex = 2) %>% # 2 for female
    rename(y_occup = y_occup_f,
           y_future_farm = y_future_farm_f, 
           y_keen_emigr = y_keen_emigr_f)
  
  # Combine male and female data
  youth_emp <- rbind(youth_emp_m, youth_emp_f) %>%
    mutate(ymembers = hh_myoung + hh_fyoung) 
  
  YouthScore <- youth_emp %>%
    # Employment
    mutate(y_good = ifelse(y_occup %in% c(1,4,5,6),1,0),
           y_med = ifelse(y_occup %in% c(2),1,0),
           y_bad = ifelse(y_occup %in% c(0,3),1,0)) %>%
    # Emigration
    mutate(g1 = ifelse(y_future_farm == 1 & y_keen_emigr == 0,1,0), 
           g2 = ifelse(y_future_farm == 0 & y_keen_emigr == 1,1,0),
           g3 = ifelse(y_future_farm == 1 & y_keen_emigr == 1,1,0),
           g4 = ifelse(y_future_farm == 0 & y_keen_emigr == 0,1,0)) %>%
    group_by(key) %>% # make sum per farm
    # Employment
    mutate(y_good_sum = sum(y_good, na.rm = T),
           y_med_sum = sum(y_med, na.rm = T),
           y_bad_sum = sum(y_bad, na.rm = T),
           ymembers = sum(c(y_good,y_bad,y_med), na.rm = T)) %>%
    # Emigration
    mutate(g1_sum = sum(g1, na.rm = TRUE),
           g2_sum = sum(g2, na.rm = TRUE),
           g3_sum = sum(g3, na.rm = TRUE),
           g4_sum = sum(g4, na.rm = TRUE)) %>%
    # Employment score
    mutate(y_good_perc = y_good_sum*100/ymembers,
           y_med_perc = y_med_sum*100/ymembers,
           y_bad_perc = y_bad_sum*100/ymembers) %>% 
    mutate(youth_employ = (y_good_perc + 0.5*y_med_perc)/1.5) %>%
    # Emigration score
    mutate(g1_perc = g1_sum/ymembers*100,
           g2_perc = g2_sum/ymembers*100,
           g3_perc = g3_sum/ymembers*100,
           g4_perc = g4_sum/ymembers*100) %>% 
    mutate(youth_emigr = (g1_perc + 0.5*g3_perc + 0.5*g4_perc)/2) %>%
    # Total youth score
    rowwise() %>%
    mutate(youth_score = mean(c(youth_employ , youth_emigr),na.rm = T)) %>%
    mutate(youth_score = ifelse(ymembers == 0,NA,youth_score)) %>%
    select(key, youth_employ, youth_emigr, youth_score) %>%
    distinct()
  
  ## Calculate Youth score by sex
  # Male
  YouthScore_male <- youth_emp_m %>%
    # Employment
    mutate(y_good = ifelse(y_occup %in% c(1,4,5,6),1,0),
           y_med = ifelse(y_occup %in% c(2),1,0),
           y_bad = ifelse(y_occup %in% c(0,3),1,0)) %>%
    # Emigration
    mutate(g1 = ifelse(y_future_farm == 1 & y_keen_emigr == 0,1,0), 
           g2 = ifelse(y_future_farm == 0 & y_keen_emigr == 1,1,0),
           g3 = ifelse(y_future_farm == 1 & y_keen_emigr == 1,1,0),
           g4 = ifelse(y_future_farm == 0 & y_keen_emigr == 0,1,0)) %>%
    group_by(key) %>% # make sum per farm
    # Employment
    mutate(y_good_sum = sum(y_good, na.rm = T),
           y_med_sum = sum(y_med, na.rm = T),
           y_bad_sum = sum(y_bad, na.rm = T),
           ymembers = sum(c(y_good,y_bad,y_med), na.rm = T)) %>%
    # Emigration
    mutate(g1_sum = sum(g1, na.rm = TRUE),
           g2_sum = sum(g2, na.rm = TRUE),
           g3_sum = sum(g3, na.rm = TRUE),
           g4_sum = sum(g4, na.rm = TRUE)) %>%
    # Employment score
    mutate(y_good_perc = y_good_sum*100/ymembers,
           y_med_perc = y_med_sum*100/ymembers,
           y_bad_perc = y_bad_sum*100/ymembers) %>% 
    mutate(youth_employ = (y_good_perc + 0.5*y_med_perc)/1.5) %>%
    # Emigration score
    mutate(g1_perc = g1_sum/ymembers*100,
           g2_perc = g2_sum/ymembers*100,
           g3_perc = g3_sum/ymembers*100,
           g4_perc = g4_sum/ymembers*100) %>% 
    mutate(youth_emigr = (g1_perc + 0.5*g3_perc + 0.5*g4_perc)/2) %>%
    # Total youth score
    rowwise() %>%
    mutate(youth_score_male = mean(c(youth_employ , youth_emigr),na.rm = T)) %>%
    mutate(youth_score_male = ifelse(ymembers == 0,NA,youth_score_male)) %>%
    select(key, youth_score_male) %>%
    distinct()
  
  ## Female
  YouthScore_female <- youth_emp_f %>%
    # Employment
    mutate(y_good = ifelse(y_occup %in% c(1,4,5,6),1,0),
           y_med = ifelse(y_occup %in% c(2),1,0),
           y_bad = ifelse(y_occup %in% c(0,3),1,0)) %>%
    # Emigration
    mutate(g1 = ifelse(y_future_farm == 1 & y_keen_emigr == 0,1,0), 
           g2 = ifelse(y_future_farm == 0 & y_keen_emigr == 1,1,0),
           g3 = ifelse(y_future_farm == 1 & y_keen_emigr == 1,1,0),
           g4 = ifelse(y_future_farm == 0 & y_keen_emigr == 0,1,0)) %>%
    group_by(key) %>% # make sum per farm
    # Employment
    mutate(y_good_sum = sum(y_good, na.rm = T),
           y_med_sum = sum(y_med, na.rm = T),
           y_bad_sum = sum(y_bad, na.rm = T),
           ymembers = sum(c(y_good,y_bad,y_med), na.rm = T)) %>%
    # Emigration
    mutate(g1_sum = sum(g1, na.rm = TRUE),
           g2_sum = sum(g2, na.rm = TRUE),
           g3_sum = sum(g3, na.rm = TRUE),
           g4_sum = sum(g4, na.rm = TRUE)) %>%
    # Employment score
    mutate(y_good_perc = y_good_sum*100/ymembers,
           y_med_perc = y_med_sum*100/ymembers,
           y_bad_perc = y_bad_sum*100/ymembers) %>% 
    mutate(youth_employ = (y_good_perc + 0.5*y_med_perc)/1.5) %>%
    # Emigration score
    mutate(g1_perc = g1_sum/ymembers*100,
           g2_perc = g2_sum/ymembers*100,
           g3_perc = g3_sum/ymembers*100,
           g4_perc = g4_sum/ymembers*100) %>% 
    mutate(youth_emigr = (g1_perc + 0.5*g3_perc + 0.5*g4_perc)/2) %>%
    # Total youth score
    rowwise() %>%
    mutate(youth_score_female = mean(c(youth_employ , youth_emigr),na.rm = T)) %>%
    mutate(youth_score_female = ifelse(ymembers == 0,NA,youth_score_female)) %>%
    select(key, youth_score_female) %>%
    distinct()
  
  YouthScore <- YouthScore %>%
    left_join(YouthScore_male, by = 'key') %>%
    left_join(YouthScore_female, by = 'key')

  return(YouthScore)

```

### Biodiversity Indicator

The Biodiversity Indicator has two different options to calculate it is depending on the configuration of the yml file. There you can enter **Agrobiodiversity** (for the standard TAPE index) or **Biodiversity** (for the new Biodiversity index) depending on the calculation you want. Calculating the new Biodiversity index needs a more extensive questionnaire and can't be calculated by the questions of the base TAPE questionnaire.

Here we will first explain the "old" way to calculate the Biodiversity Indicator. The data gets grouped by the name of the crop species (**cname_label**) and **key**. The sum of the in the code listed variables is calculated per plant species per farm. The standard Agrobiodiversity index is the mean of the Gini-Simpson-Index for crops, the Gini-Simpson-Index for animals and the score for other natural vegetation and beekeping.

The land under production per crop (**cland**) is added up **cland_sum**, for the whole cropland of the farm. Later **(cland/cland_sum)\^2/cvar** is defined as **p2\_**. The sum of **p2\_** for every farm is defined as **shannon**. NA values for **shannon** are changed to 0. The **GSIndex_crops** is calculated for every farm and defined as 100\*(1 - **shannon**).

```{r}
## Crops
  c1 <- data_Crops %>% 
    group_by(cname_id, key) %>%
    mutate(cprod = sum(cprod, na.rm = TRUE),
           cqsold = sum(cqsold, na.rm = TRUE),
           cpg = mean(cpg, na.rm = TRUE),
           cgift = sum(cgift, na.rm = TRUE),
           cland_ha = sum(cland_ha, na.rm = TRUE),
           cvar = sum(cvar, na.rm = TRUE)) %>%  
    ungroup() %>%
    select(key, cname_id, cland_ha, cvar) %>%
    arrange(cname_id) %>% 
    distinct() %>% as.data.frame()
  
  c1 <- c1 %>%
    mutate(cvar = ifelse(cvar > 50, 1, cvar)) %>%
    group_by(key) %>%
    mutate(cland_ha_sum = sum(cland_ha, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(key) %>%
    mutate(p2_ = (cland_ha/cland_ha_sum)^2/cvar)
  
  c1 <- c1 %>%
    group_by(key) %>%
    mutate(shannon = sum(p2_, na.rm = TRUE)) %>% 
    ungroup() %>%
    mutate(shannon = ifelse(is.na(shannon), 1, shannon)) %>%
    mutate(GSIndex_crops = 100*(1 - shannon)) %>%
    select(!c("p2_"))
  
  GSIndex_crops <- c1 %>%
    group_by(key, shannon, GSIndex_crops) %>%
    distinct(key)
  rm(c1)
```

First the lsucv for different animal categories are taken from the config file. The data is grouped by the name of the animal species (**aname**) and **key**. The sum of the in the code listed variables is calculated per animal species per farm. After that the livestock standard units were defined as the variable **livunit**. **nliv** is then defined as the lifestock units times the number of individuals for every animals on every farm e.g. if a farm has 3 pigs **nliv** would = 3\* 0.2 (the livestocunit for pigs).

```{r}
## Animals
  # import selected livestock unit conversion units from config file
  lsucv_cattle <- cfg$lsucv_cattle
  lsucv_buffalo <- cfg$lsucv_buffalo
  lsucv_sheep <- cfg$lsucv_sheep
  lsucv_pig <- cfg$lsucv_pig
  lsucv_horses <- cfg$lsucv_horses
  lsucv_camels <- cfg$lsucv_camels
  
  a1 <- data_Animals %>% 
    group_by(an_id,key) %>%
    mutate(arais = sum(arais, na.rm = TRUE),
           aborn = sum(aborn, na.rm = TRUE),
           adied = sum(adied, na.rm = TRUE),
           abreed = sum(abreed, na.rm = TRUE),
           aslaughter = sum(aslaughter, na.rm = T),
           abuy = sum(abuy, na.rm = T),
           aqsold = sum(aqsold, na.rm = TRUE),
           apg = sum(apg, na.rm = TRUE),
           aqgift = sum(aqgift, na.rm = TRUE)) %>% 
    ungroup() %>%
    select(key, an_id, arais, aborn, adied, abreed, aslaughter, abuy, aqsold, apg, aqgift) %>%
    arrange(an_id) %>% distinct() %>% as.data.frame()
  
  # We convert in livestok standard units:
  a1 <- a1 %>%
    mutate(livunit = case_when(an_id == 0 ~ lsucv_cattle, # an_id == 0 --> "Cow / Bull"
                               an_id %in% c(1,2) ~ lsucv_buffalo, # Bison & Water buffalo
                               an_id == 3 ~ lsucv_horses, # Horse
                               an_id == 4 ~ 0.8, # Reindeer 
                               an_id %in% c(5,6) ~ 0.3, # Donkey & Mule
                               an_id == 7 ~ lsucv_sheep, # Sheep
                               an_id %in% c(8, 23) ~ 0.1, # Goat (8) & Crocodiles and other reptiles (23)
                               an_id == 9 ~ lsucv_pig, # Pig
                               an_id == 10 ~ lsucv_camels, # Camel
                               an_id == 11 ~ 0.17, # Llama
                               an_id == 12 ~ 0.02, # Rabbit
                               an_id %in% c(13, 19) ~ 0.01, # Chicken (13) & Fish (19)
                               an_id %in% c(14, 15, 16, 22) ~ 0.03, # Duck (14) & Goose (15) & Turkey (16) & Peacock (22)
                               an_id == 17 ~ 0.005, # Pigeon
                               an_id == 18 ~ 0.35, # Ostrich
                               an_id == 20 ~ 0.003, # Crustaceans
                               an_id == 21 ~ 0.002)) %>% # Molluscs
    mutate(nliv = livunit * arais) # Multiplying livestock units per number of individuals
  
```

The sum of **nliv** on every farm for every animal is taken and defined as **nliv_sum** . "p2\_" is defined as **(nliv/nliv_sum)\^2/abreed)** and summed up for every farm to get the **shannon_a**. The **GSIndex_animals** is calculated as **GSIndex_animals** = 100\*(1 - **shannon_a**).

```{r}
 a1 <- a1 %>%
    group_by(key) %>%
    mutate(nliv_sum = sum(nliv, na.rm = TRUE)) %>%  # total livestock size in SLU/TLU
    ungroup() %>%
    mutate(p2_ = (nliv/nliv_sum)^2/abreed) %>%   # weighted shares
    group_by(key) %>%
    mutate(shannon_a = sum(p2_, na.rm = TRUE)) %>% # shannon index
    ungroup() %>%
    mutate(shannon_a = ifelse(is.na(shannon_a), 1, shannon_a)) %>% 
    mutate(GSIndex_animals = 100*(1 - shannon_a)) %>%
    mutate(GSIndex_animals = ifelse(nliv == nliv_sum & abreed == 1, 10, GSIndex_animals)) %>% # Farms with only one animal category and 1 breed get a value of 10 instead of 0
    select(!c("p2_")) %>%
    filter(!nliv == 0)
  
  GSIndex_animals <- a1 %>%
    group_by(key, shannon_a, GSIndex_animals) %>%
    distinct(key)
  rm(a1)
```

**nat_veg, bee** and **poll** describe the Natural Vegetation, Beekeeping and Presence of Pollinators and have the following scores:

| Answer                                                                                 | Score |
|----------------------------------------------------------------------------------------|-------|
| **Natural Vegetation**                                                                 |       |
| Absent: area covered with natural or diverse vegetation is negligible.                 | 0     |
| Small: less than 10% of the system is covered with natural or diverse vegetation.      | 0.33  |
| Significant: at least 20% of the system is covered with natural or diverse vegetation. | 0.66  |
| Abundant: more than 25% of the system is covered with natural or diverse vegetation.   | 1     |
| **Beekeeping**                                                                         |       |
| No, bees are not raised and are rare within the agroecosystem.                         | 0     |
| No, bees are not raised but are widespread within the agroecosystem.                   | 0.5   |
| Yes, bees are raised within the agroecosystem.                                         | 1     |
| **Presence of Pollinators**                                                            |       |
| Absent                                                                                 | 0     |
| Little                                                                                 | 0.33  |
| Significant                                                                            | 0.66  |
| Abundant                                                                               | 1     |

**b_gini** is then defined as the mean of these scores and **GSI_other** is **b_gini** multiplied by 100.

```{r}
## Beekeping & other
  data_b <- data[,c('key', 'nat_veg', 'bee', 'poll')]
  data_b <- data_b %>%
    mutate(natveg_score = case_when(nat_veg == 1 ~ 0,
                                    nat_veg == 2 ~ 0.33,
                                    nat_veg == 3 ~ 0.66,
                                    nat_veg == 4 ~ 1),
           bee_score = case_when(bee == 3 ~ 0,
                                 bee == 2 ~ 0.5,
                                 bee == 1 ~ 1),
           poll_score = case_when(poll == 1 ~ 1,
                                  poll == 2 ~ 0.66,
                                  poll == 3 ~ 0.33,
                                  poll == 4 ~ 0))
  
  data_b <- data_b %>%
    rowwise() %>%
    mutate(b_gini = mean(c(natveg_score, bee_score, poll_score), na.rm = T)) %>%
    mutate(GSI_other = b_gini*100)
```

For the **Agricultural_biodiversity** the mean of the three GSI is taken. The data frame **Agricultural_biodiversity** is defined as **GSI_overall** data frame containing the calculated data from this step.

```{r}
## OVERALL GINI-SIMPSON DIVERSITY INDEX
  GSI_overall <- GSIndex_crops %>%
    left_join(GSIndex_animals, by = 'key') %>%
    left_join(data_b[,c('key', 'GSI_other')], by = 'key') %>%
    rowwise() %>%
    mutate(Agricultural_diversity_tape = mean(c(GSIndex_crops, GSIndex_animals, GSI_other), na.rm = T))
  rm(GSIndex_crops, GSIndex_animals, data_b)
  
  Agricultural_biodiversity <- GSI_overall
  
  return(Agricultural_biodiversity)
  
```

The new Biodiversity score consists of 10 indices:

-   Agricultural diversity (old TAPE index, without natveg, bees & pollinators)

-   Patch size

-   Tree habitat

-   Semi-natural Habitats

-   Nitrogen application

-   Pesticide application

-   Mechanical Field operations

-   Stocking rate

-   Grazing intensity

-   Land use change

Each of this indices gives a value between 0-100 % and the total Biodiversity index is the mean of these 10 indices.

The new score starts exactly the same as the old one with calculating **GSIndex_crops** and **GSIndex_animals**. Here **Agricultural_diversity** is defined as the mean of **GSIndex_crops** and **GSIndex_animals**.

```{r}
## 2.6.1  Agricultural diversity - standard TAPE index, however only GSI from Animals and Crops
  Ag_biodiversity <- step2_Agricultural_Biodiversity()
  Ag_biodiversity <- Ag_biodiversity %>%
    rowwise() %>%
    mutate(Agricultural_diversity = mean(c(GSIndex_crops, GSIndex_animals), na.rm = T))
```

The area of semi natural habitats (**SNH_area_ha**) is taken from **sizeha_snh** or calculated from **length_snh** and **width_snh**. Then the total SNH area for every farm is calculated by adding all the SNH patches (**SNH_area_ha**) of a farm together. The **total_area** for every farm is calculated through the sum of the total area under agricultural production, the grazing area and the area of semi natural habitats.

```{r}
 # Total Agricultural area is used for different indices 
  # Total agricultural Area (total area under agricultural production + total grazing area + area semi natural habitats)
  snh_data <- data_snh %>% # Data on Semi-natural habitats
    mutate(SNH_area_ha = ifelse(is.na(sizeha_snh), length_snh*width_snh*0.0001,sizeha_snh)) %>%
    group_by(key) %>%
    summarise_at(vars(SNH_area_ha), sum, na.rm = T)
  
  Area_total <- data[, c('key', 'area_ha', 'area_natural_veg_ha', 'area_permanent_pasture_ha', 'area_common_pasture_ha')] %>%
    left_join(snh_data, by = 'key') %>%
    rowwise() %>%
    mutate(area_total = sum(area_ha, area_natural_veg_ha, area_permanent_pasture_ha, area_common_pasture_ha, SNH_area_ha, na.rm = T))
  
```

The Patch size is calculated by dividing the area of the fields (**crop_field_area**) by the amount of fields. This variable is called **Patch_size**. It is then ordered to a score seen in the following table:

| Patch size | score |
|------------|-------|
| \<0.5      | 100   |
| 0.5 - 3    | 75    |
| 3 - 16     | 50    |
| 16- 100    | 25    |
| \>= 100    | 0     |

```{r}
 ## 2.6.2 Patch size
  # only crop fields are considered
  Patch_size <- data[,c('key', 'crops_fields', 'crops_fields_area')]
  Patch_size <- Patch_size %>%
    mutate(Patch_size_n = crops_fields_area/crops_fields, # Medium patch size for crops
           Patch_size = case_when(Patch_size_n < 0.5 ~ 100,
                                  Patch_size_n >= 0.5 & Patch_size_n < 3 ~ 75,
                                  Patch_size_n >= 3 & Patch_size_n < 16 ~ 50,
                                  Patch_size_n >= 16 & Patch_size_n < 100 ~ 25,
                                  Patch_size_n >= 100 ~ 0))
  
  Ag_biodiversity <- Ag_biodiversity %>%
    left_join(Patch_size, by = 'key')
  rm(Patch_size)
```

The tree data is grouped by key and the size of the area covered by trees is then summed together for every farm (**sizeha**) . The variable **tree_lines_ha** is created and calculated as the area of the tree lines, as this was not included in **sizeha**. The two variables are then added together to create **tree_total_area**, which is then divided by the total area (calculated before) to get the variable **Tree_habitat**. It is multiplied by 100 to get the value in %.

```{r}
## 2.6.3 Tree habitat
  Tree <- data_tree %>%
    group_by(key) %>%
    summarise_at(vars(sizeha), sum, na.rm = T)
  
  Tree_habitat <- data[,c('key', 'width', 'length')] # width and length of tree lines in m
  Tree_habitat <- Tree_habitat %>%
    left_join(Tree, by = 'key') %>%
    mutate(tree_lines_ha = length * width * 0.0001) %>% # length and width are in m
    rowwise() %>%
    mutate(tree_area_total = sum(tree_lines_ha, sizeha, na.rm = T)) %>%
    left_join(Area_total, by = 'key') %>%
    mutate(Tree_habitat = (tree_area_total/area_total)*100)
  
  Ag_biodiversity <- Ag_biodiversity %>%
    left_join(Tree_habitat[,c('key', 'sizeha', 'tree_lines_ha', 'Tree_habitat')], by = 'key')
  rm(Tree_habitat, Tree)
```

The variable **count** is created in the new data frame SNH_div. It describes how many different semi natural habitats exist on one farm. These can be Hedges, Grasslands, Aquatic habitats etc. **SNH_area_ind** is a indicator that scales the percentage of SNH area of the farm. It is multiplied by 4 so that 25% SNH reaches the maximal score of 1. **SNH_div_ind** translates the variable **count** to a score as follows:

| count | SNH_div_ind |
|-------|-------------|
| \> 5  | 1           |
| 4     | 0.75        |
| 3     | 0.5         |
| 2     | 0.25        |
| \< 2  | 0           |

The mean of **SNH_div_ind** and \***SNH_area_ind** is taken as the final score **Semi_natural_habitats**. It is again multiplied by 100 to have the value in %. These three variables are then joined to the Agricultural_biodiversity data frame.

```{r}
## 2.6.4 Semi-natural Habitats
  SNH <- data_snh
  # diversity of SNH 
  SNH_div <- SNH %>%
    group_by(key) %>%
    summarise(count = n_distinct(snhname)) %>%
    mutate_all(., as.numeric)
  
  SemiNaturalHabitats <- Area_total %>%
    left_join(SNH_div, by = 'key') %>%
    mutate(SNH_area_ind =  SNH_area_ha/area_total * 4) %>%# x 4, so that 25% of SNH gives max points
    mutate(SNH_area_ind = ifelse(SNH_area_ind >= 1, 1, SNH_area_ind)) %>%
    mutate(SNH_div_ind = case_when(count >= 5 ~ 1,
                                   count == 4 ~ 0.75,
                                   count == 3 ~ 0.5,
                                   count == 2 ~ 0.25,
                                   count < 2 ~ 0)) %>%
    mutate(Semi_natural_Habitats = (SNH_area_ind + SNH_div_ind)/2) %>%
    mutate(Semi_natural_Habitats = Semi_natural_Habitats * 100) %>%
    mutate(Semi_natural_Habitats = ifelse(is.na(Semi_natural_Habitats), 0, Semi_natural_Habitats))
  
  Ag_biodiversity <- Ag_biodiversity %>%
    left_join(SemiNaturalHabitats[,c('key', 'SNH_area_ind', 'SNH_div_ind', 'Semi_natural_Habitats')], by = 'key')
  rm(SNH, SNH_div, SemiNaturalHabitats)
```

The **FertArea** is defined as 1 - the proportion of fertilized area compared to the total area. **N_input** is the score derived from the variable **fert_intensity**. **fert_intensity** describes the amount of organic/synthetic fertilizer was applied on the farm on a score from 1-5. **N_input** then translates it on a score from 0-1. The mean of **N_input** and **FertArea** (transformed to %) is defined as the variable **N_application** and the three new variables are joined to the data frame **Agricultural_biodiversity**.

```{r}
## 2.6.5 Nitrogen application
  N_Fert <- data[, c('key', 'fert_ha', 'fert_intensity')] %>%
    left_join(Area_total, by = 'key') %>%
    mutate(FertArea = 1 - (fert_ha/area_total)) %>%
    mutate(N_input = case_when(fert_intensity == 1 ~ 1,
                               fert_intensity == 2 ~ 0.75,
                               fert_intensity == 3 ~ 0.5,
                               fert_intensity == 4 ~ 0.25,
                               fert_intensity == 5 ~ 0)) %>%
    mutate(N_application = (FertArea + N_input)/2) %>%
    mutate(N_application = N_application * 100)
  
  Ag_biodiversity <- Ag_biodiversity %>%
    left_join(N_Fert[,c('key', 'FertArea', 'N_input', 'N_application')], by = 'key')
  rm(N_Fert)
  
```

First the number of applications of pesticides (**cpapp_num**) is summed up to a total for each farm. **toxicity** is defined as the smaller toxicity level of either human or environmental pesticide toxicity (the highest toxicity has the value of 1 and the lowest 3). **nr_Appl_ha** is defined as number of pesticide application per hectare farmland. It is then translated to a score called **cp** as follows:

| nr_Appl_ha    | cp  |
|---------------|-----|
| \>= 10        | 0   |
| \< 10 & \>= 9 | 0.1 |
| \< 9 & \>= 8  | 0.2 |
| \< 8 & \>= 7  | 0.3 |
| \< 7 & \>= 6  | 0.4 |
| \< 6 & \>= 5  | 0.5 |
| \< 5 & \>= 4  | 0.6 |
| \< 4 & \>= 3  | 0.7 |
| \< 3 & \>= 2  | 0.8 |
| \< 2 & \>= 1  | 0.9 |
| \< 1          | 1   |

**cp_area** is defined as **1 - (cpestareaf/area_total)**. Which is 1 - the area where pesticides were applied divided by the total farm area. **cp_ecotox** is defined through the **toxicity** score as follows:

| toxicity | cp_ecotox |
|----------|-----------|
| NA       | 1         |
| 3        | 0.67      |
| 2        | 0.33      |
| 1        | 0         |

The last variable **cp_ind** is defined by the mean of the three variables : **cp, cp_area, cp_ecotox**. Then all four variables were added to the Agricultural_biodiversity data frame.

```{r}
## 2.6.6 Pesticide application
  ## Pesticide application
  
  cp <- data_Chemical_Pesticide %>%
    group_by(key) %>%
    summarise_at(vars(cpspray), sum, na.rm = T) 
  
  ## Toxiocology
  cp_tox <- data_Chemical_Pesticide %>%
    mutate(toxicity = ifelse(cptox <= cptoxenv, cptox, cptoxenv)) %>%
    group_by(key) %>%
    summarise_at(vars(toxicity), min, na.rm = T)
  
  ## Area
  pesticides <- data[,c('key', 'cpestareaf')] %>%
    left_join(Area_total, by = 'key') %>%
    left_join(cp, by = 'key') %>%
    left_join(cp_tox, by = 'key') %>%
    mutate(nr_Appl_ha = cpapp_num/area_total) %>%
    mutate(cp = case_when(nr_Appl_ha >= 10 ~ 0,
                          nr_Appl_ha < 10 & nr_Appl_ha >= 9 ~ 0.1,
                          nr_Appl_ha < 9 & nr_Appl_ha >= 8 ~ 0.2,
                          nr_Appl_ha < 8 & nr_Appl_ha >= 7 ~ 0.3, 
                          nr_Appl_ha < 7 & nr_Appl_ha >= 6 ~ 0.4,
                          nr_Appl_ha < 6 & nr_Appl_ha >= 5 ~ 0.5,
                          nr_Appl_ha < 5 & nr_Appl_ha >= 4 ~ 0.6,
                          nr_Appl_ha < 4 & nr_Appl_ha >= 3 ~ 0.7,
                          nr_Appl_ha < 3 & nr_Appl_ha >= 2 ~ 0.8,
                          nr_Appl_ha < 2 & nr_Appl_ha >= 1 ~ 0.9,
                          nr_Appl_ha < 1 ~ 1)) %>%
    mutate(cp = replace_na(cp, 1)) %>%
    mutate(cp_area = 1 - (cpestareaf/area_total)) %>%
    mutate(cp_area = ifelse(cp_area < 0, 0, cp_area)) %>%
    mutate(cp_ecotox = case_when(is.na(toxicity) ~ 1,
                                 toxicity == 3 ~ 0.67,
                                 toxicity == 2 ~ 0.33,
                                 toxicity == 1 ~ 0)) %>%
    rowwise() %>%
    mutate(cp_ind = mean(c(cp, cp_area, cp_ecotox))) %>%
    mutate(cp_ind = cp_ind * 100)
  
  Ag_biodiversity <- Ag_biodiversity %>%
    left_join(pesticides[,c('key', 'cp', 'cp_area', 'cp_ecotox', 'cp_ind')], by = 'key')
  rm(cp, cp_tox, pesticides)
```

**field_op_nr** are the number of mechanized field operations per field on average. **FieldOP** is the corresponding score to it. The translation is shown in the table:

| field_op_nr | FieldOP |
|-------------|---------|
| 1           | 100     |
| 2           | 75      |
| 3           | 50      |
| 4           | 25      |
| 5           | 0       |

FieldOP is then added to the data frame Agricultural_biodiversity.

```{r}
### 2.6.7 Mechanical Field operations
  Fieldoperations <- data[,c('key', 'mechz_fieldops')] %>%
    rename(field_op_nr = `mechz_fieldops`) %>%
    mutate(FieldOP = case_when(field_op_nr == 1 ~ 100,
                               field_op_nr == 2 ~ 75,
                               field_op_nr == 3 ~ 50,
                               field_op_nr == 4 ~ 25,
                               field_op_nr == 5 ~ 0))
  
  Ag_biodiversity <- Ag_biodiversity %>%
    left_join(Fieldoperations[,c('key', 'FieldOP')], by = 'key')
  rm(Fieldoperations)
```

**arais** is for the data frame Stockingrate is defined different as before. As the data was also grouped by **onfarm** (percentage of time spent on farm pastures) it is now defined as the number of animals from a species that has spent this percentage of time on the pasture, for every farm. (e.g. on a farm 4 cows on the farm spend 50% of their time on a pasture and 3 spend 70%, the farm would have an arais score of 3 and one of 4) **livunit** still are the livestock units and **nliv** is **arais** scaled with the livestock units. **stocking_rate** is defined as **nliv** per farm area. **AvStock** is the score for **stocking_rate** and translates in a linear scale defined through the following function: **AvStock** = 100-(25 \* **stocking_rate**) when **stocking_rate** is over 4 **AvStock** is 0.

**AvStock** is then added to the data frame Agricultural_biodiversity.

```{r}
### 2.6.8 Stocking rate
  # Number of animals converted to livestock units (lU/ha)
  Stockingrate <- data_Animals 
  
  Stockingrate <- Stockingrate %>% 
    group_by(an_id, key, onfarm) %>%
    mutate(arais = sum(arais, na.rm = TRUE)) %>% 
    ungroup() %>%
    select(an_id, key, arais, onfarm) %>%
    distinct() %>% as.data.frame()
  
  # We convert in livestok standard units:
  # import selected livestock unit conversion units from config file
  lsucv_cattle <- cfg$lsucv_cattle
  lsucv_buffalo <- cfg$lsucv_buffalo
  lsucv_sheep <- cfg$lsucv_sheep
  lsucv_pig <- cfg$lsucv_pig
  lsucv_horses <- cfg$lsucv_horses
  lsucv_camels <- cfg$lsucv_camels
  
  Stockingrate <- Stockingrate %>%
    mutate(livunit = case_when(an_id == 0 ~ lsucv_cattle, # an_id == 0 --> "Cow / Bull"
                               an_id %in% c(1,2) ~ lsucv_buffalo, # Bison & Water buffalo
                               an_id == 3 ~ lsucv_horses, # Horse
                               an_id == 4 ~ 0.8, # Reindeer 
                               an_id %in% c(5,6) ~ 0.3, # Donkey & Mule
                               an_id == 7 ~ lsucv_sheep, # Sheep
                               an_id %in% c(8, 23) ~ 0.1, # Goat (8) & Crocodiles and other reptiles (23)
                               an_id == 9 ~ lsucv_pig, # Pig
                               an_id == 10 ~ lsucv_camels, # Camel
                               an_id == 11 ~ 0.17, # Llama
                               an_id == 12 ~ 0.02, # Rabbit
                               an_id %in% c(13, 19) ~ 0.01, # Chicken (13) & Fish (19)
                               an_id %in% c(14, 15, 16, 22) ~ 0.03, # Duck (14) & Goose (15) & Turkey (16) & Peacock (22)
                               an_id == 17 ~ 0.005, # Pigeon
                               an_id == 18 ~ 0.35, # Ostrich
                               an_id == 20 ~ 0.003, # Crustaceans
                               an_id == 21 ~ 0.002)) %>% # Molluscs
    mutate(nliv = livunit * arais) %>% # Multiplying livestock units per number of individuals
    group_by(key) %>%
    summarise_at(vars(nliv), sum, na.rm = T)
  
  Stockingrate <- Stockingrate %>%
    left_join(Area_total, by = 'key') %>%
    mutate(stocking_rate = nliv/area_total) %>%
    mutate(AvStock = case_when(stocking_rate > 4 ~ 0,
                               stocking_rate <= 4 ~ (100-(25 * stocking_rate))))
  
  Ag_biodiversity <- Ag_biodiversity %>%
    left_join(Stockingrate[,c('key', 'AvStock')], by = 'key')
  rm(Stockingrate)
```

**arais** is again defined as the number of animals from a species that has spent this percentage of time on the pasture, for every farm. **nliv** is calculated as before and contains the same values. **pasture_d** is the percentage of time spent on the pasture times **nliv**. The sum of **pasture_d**, **nliv** and **livunit** is taken for every farm separatly. The grazing intensity (**GI**) is then defined by first calculating **pasture_d** per grazing area on the farm and then translating it to the final score **Grazing_intensity** as follows:

| GI         | Grazing_intensity |
|------------|-------------------|
| \> 2       | 0                 |
| 2 - 1      | 25                |
| 1 - 0.5    | 50                |
| 0.5 - 0.25 | 75                |
| \<= 0.25   | 100               |

**Grazing_intensity** is added to the data frame Agricultural_biodiversity.

```{r}
  ### 2.6.9 Grazing intensity
  Grazing_intensity <- data_Animals 
  
  Grazing_intensity <- Grazing_intensity %>% 
    group_by(an_id, key, onfarm) %>%
    mutate(arais = sum(arais, na.rm = TRUE)) %>% 
    ungroup() %>%
    select(an_id, key, arais, onfarm) %>%
    distinct() %>% as.data.frame()
  
  # We convert in livestok standard units:
  Grazing_intensity <- Grazing_intensity %>%
    mutate(livunit = case_when(an_id == 0 ~ lsucv_cattle, # an_id == 0 --> "Cow / Bull"
                               an_id %in% c(1,2) ~ lsucv_buffalo, # Bison & Water buffalo
                               an_id == 3 ~ lsucv_horses, # Horse
                               an_id == 4 ~ 0.8, # Reindeer 
                               an_id %in% c(5,6) ~ 0.3, # Donkey & Mule
                               an_id == 7 ~ lsucv_sheep, # Sheep
                               an_id %in% c(8, 23) ~ 0.1, # Goat (8) & Crocodiles and other reptiles (23)
                               an_id == 9 ~ lsucv_pig, # Pig
                               an_id == 10 ~ lsucv_camels, # Camel
                               an_id == 11 ~ 0.17, # Llama
                               an_id == 12 ~ 0.02, # Rabbit
                               an_id %in% c(13, 19) ~ 0.01, # Chicken (13) & Fish (19)
                               an_id %in% c(14, 15, 16, 22) ~ 0.03, # Duck (14) & Goose (15) & Turkey (16) & Peacock (22)
                               an_id == 17 ~ 0.005, # Pigeon
                               an_id == 18 ~ 0.35, # Ostrich
                               an_id == 20 ~ 0.003, # Crustaceans
                               an_id == 21 ~ 0.002)) %>% # Molluscs
    mutate(nliv = livunit * arais) %>% # Multiplying livestock units per number of individuals
    mutate(pasture_d = nliv * onfarm/100) %>% # livestock times percentage on farm
    group_by(key) %>%
    summarise_at(vars(pasture_d, nliv, livunit), sum, na.rm = T)
  
  Grazing_intensity <- Grazing_intensity %>%
    left_join(Area_total, by = 'key') %>%
    mutate(GI = pasture_d/area_g) %>%
    mutate(Grazing_intensity = case_when(GI > 2 ~ 0,
                                         GI <= 2 & GI > 1 ~ 25,
                                         GI <= 1 & GI > 0.5 ~ 50,
                                         GI <= 0.5 & GI > 0.25 ~ 75,
                                         GI <= 0.25 ~ 100))
  
  Grazing_intensity <- Grazing_intensity %>%
    mutate(Grazing_intensity = ifelse(area_g == 0, NA, Grazing_intensity)) # Farmers that have no On-farm pastures have grazing intensity NA
  
  Ag_biodiversity <- Ag_biodiversity %>%
    left_join(Grazing_intensity[,c('key', 'Grazing_intensity')], by = 'key')
```

The variable **landuse_change** describes the area that was newly converted from natural/semi-natural vegetation to agricultural fields. **LUC_SNH** is 1 - the converted area divided by the total farm area. It is then multiplied by 100. If none of the area was changed the farm received a score of 100. **LUC_SNH** is then added to the data frame Agricultural_biodiversity.

```{r}
 ### 2.6.10 Land use change
  LUC <- data[,c('key', 'landuse_change')] %>%
    left_join(Area_total, by = 'key') %>%
    mutate(LUC_SNH = 1 - (landuse_change/area_total)) %>%
    mutate(LUC_SNH = LUC_SNH * 100) %>%
    mutate(LUC_SNH = ifelse(is.na(LUC_SNH), 100, LUC_SNH))
  
  Ag_biodiversity <- Ag_biodiversity %>%
    left_join(LUC[,c('key', 'LUC_SNH')], by = 'key') 
  rm(LUC)
```

The total score for Agricultural biodiversity is called **Biodiversity_indicator**. It is calculated by the mean of all the variables we have calculated in this chapter, namely: **Agricultural_diversity, LUC_SNH, Grazing_intensity, AvStock, FieldOP, cp_ind, N_application, Semi_natural_Habitats, Tree_habitat, Patch_size**.

```{r}
### Calculation of total Biodiversity Indicator
  Ag_biodiversity <- Ag_biodiversity %>%
    rowwise() %>%
    mutate(Biodiversity_indicator = mean(c(Agricultural_diversity, LUC_SNH, Grazing_intensity, AvStock, FieldOP, cp_ind, N_application, Semi_natural_Habitats, Tree_habitat, Patch_size), na.rm = T)) %>%
    rename( "cp_appl" = "cp") 
```

### Exposure to Pesticides

First the score for organic pesticides is calculated. **coused1** is the quantity of organic pesticide used. With **comeas1** the unit of **coused1** is corrected to be in [kg]. Then **coused1** is defined as the sum of all the organic pesticides used on a farm (in kg).

```{r}
## Organic Pesticides
  
  co <- data_co %>%
    rename(key = '_parent_index') %>%
    mutate(coused1 = ifelse(is.na(coused1),NA,
                           ifelse(is.na(comeas1),coused1,
                                  ifelse(comeas1 %in% c('Grams', 'g'), coused1*0.001, coused1))))
  
  co <- co %>%
    group_by(key) %>%
    mutate(coused1 = sum(coused1, na.rm = T)) %>% 
    ungroup() %>%
    select(key, coused1) %>%
    distinct()
```

The chemical pesticides are also corrected for their unit of measure. Then three new variables were defined **tox1, tox2, tox3**. They are assigned the value of 1 depending on the value of **cptox**(the human toxicity) (1, 2 or 3). **cpused** is defined as the quantity of all the pesticides used on the farm.

```{r}
## Chemical Pesticides
  
  cp <- data_cp %>%
    rename(key = '_parent_index') %>% # Is human toxicity
    mutate(cpused = ifelse(cpmeas %in% c('Grams', 'g'), cpused*0.001, cpused)) %>% 
    mutate(tox1 = ifelse(cptox == 1,1,0),
           tox2 = ifelse(cptox == 2,1,0),
           tox3 = ifelse(cptox == 3,1,0))
  cp <- cp %>%
    group_by(key) %>%
    mutate(cpused = sum(cpused, na.rm = T),
           tox1 = ifelse(!is.na(tox1), max(tox1, na.rm = T), NA),
           tox2 = ifelse(!is.na(tox2), max(tox2, na.rm = T), NA),
           tox3 = ifelse(!is.na(tox3), max(tox3, na.rm = T), NA)) %>% 
    select(key, cpused, tox1, tox2, tox3) %>% distinct()
```

The variable for the number of mitigation strategies when applying pesticides is called **mitigation**. It is calculated by adding all the values of columns (with binary data sets [1 or 0] depending on if the mitigation strategy was present or not) for different mitigation strategies for every farm together. The same is done for ecological pest management (**ecoman_num**). The variables **opestnum** (number of different pesticides used) **co, cp , mitigation** and **ecoman_num** area added to the data frame Pesticides.

```{r}
 ## Number of mitigation strategies
  mitigation <- data %>%
    select(starts_with('mitig')) %>%
    select(!c('mitig')) %>%
    apply(1,function(x) sum(x,na.rm = T)) %>%
    data.frame() %>%
    rename(mitigation = '.')
  
  ecoman_num <- data %>%
    select(starts_with('ecoman')) %>%
    select(!c('ecoman')) %>%
    apply(1,function(x) sum(x,na.rm = T)) %>%
    data.frame() %>%
    rename(ecoman_num = ".")

  ## Combining
  Pesticides <- data %>%
    select('key', 'opestnum') %>%
    left_join(co, by = 'key') %>%
    left_join(cp, by = 'key')
  
  Pesticides <- cbind(Pesticides, mitigation, ecoman_num)
  rm(co, cp, mitigation, ecoman_num)
```

**pest_use** is defined as the score which is 0 if only chemical pesticides are used, 50 if both are used and 100 if no chemical pesticides were used. **pest_tox** is assigned a score through **tox1, tox2** and **tox3** as follows:

| tox                               | pest_tox |
|-----------------------------------|----------|
| tox1 == 1                         | 0        |
| tox2 == 1 & tox1 == 0             | 50       |
| tox3 == 1 & tox2 == 0 & tox1 == 0 | 100      |
| tox3 == 0 & tox2 == 0 & tox1 == 0 | 100      |

**pest_mitig** increases by 25 for every additional mitigation strategy (**mitigation**) and has a maximum with 100. **pest_ecoman** increases by 25 for every additional mitigation strategy (**pest_ecoman**) and has a maximum with 100. **pest_score** is the mean of the 4 newly calculated variables(**pest_use, pest_tox, pest_mitig, pest_ecoman**), or if no pesticides were used it equals 100.

```{r}
# New pest score proposed by Anina (4 scores + overall score as mean of the 4 scores)
  Pesticides <- Pesticides %>%
    mutate_if(is.numeric, ~replace_na(., 0)) %>%
    # Score 1: Organic vs. synthetic pesticide use
    mutate(pest_use = case_when(cpused > 0 & coused1 == 0 ~ 0,
                                cpused > 0 & coused1 > 0 ~ 50,
                                coused1 > cpused & cpused == 0 ~ 100)) %>%
    # Score 2: Toxicity
    mutate(pest_tox = case_when(tox1 == 1 ~ 0,
                                tox2 == 1 & tox1 == 0 ~ 50,
                                tox3 == 1 & tox2 == 0 & tox1 == 0 ~ 100,
                                tox3 == 0 & tox2 == 0 & tox1 == 0 ~ 100)) %>%
    # Score 3: Number of mitigation measures
    mutate(pest_mitig = case_when(mitigation == 0 ~ 0,
                                  mitigation == 1 ~ 25,
                                  mitigation == 2 ~ 50,
                                  mitigation == 3 ~ 75,
                                  mitigation >= 4 ~ 100)) %>%
    # Score 4: Number of ecological management measures
    mutate(pest_ecoman = case_when(ecoman_num == 0 ~ 0,
                                   ecoman_num == 1 ~ 25,
                                   ecoman_num == 2 ~ 50,
                                   ecoman_num == 3 ~ 75,
                                   ecoman_num >= 4 ~ 100)) %>%
    # Overall pest-score
    mutate(pest_score = case_when(cpused == 0 & coused1 == 0 ~ 100, # no pesticides used --> 100 % even if no ecoman and mitigation!
                                  TRUE ~ (pest_use + pest_tox + pest_mitig + pest_ecoman)/4))
  return(Pesticides)
```

### Economy

The **total_area** is calculated as before and corresponds to the total farm area

```{r}
Area_total <- data[, c('key', 'area_ha', 'area_natural_veg_ha', 'area_permanent_pasture_ha', 'area_common_pasture_ha')] %>%
    rowwise() %>%
    mutate(area_total = sum(area_ha, area_natural_veg_ha, area_permanent_pasture_ha, area_common_pasture_ha, na.rm = T))
  
```

The data for household members is saved in the data frame data_workers. **nag_children** is defined as the household children / 2. Then the sum of all the household members is taken and defined as **fam_workers** (For children **nag_children** is used). **days_ext** is the sum of all the days external people have worked on the farm and **wage** is the sum of all their wage. The **ext_workers** variable describes the ammount of external workers that worked on the farm by dividing **days_ext** through 260 (based on a 5 day workweek, this number is dependent on the project specific conditions!!). The number of workers is then described by the variable **num_workers** and is the sum of **fam_workers** and **ext_workers**.

```{r}
# Householdmembers
  hh <- data[,c('key', 'hh_men', 'hh_women', 'hh_myoung', 'hh_fyoung', 'hh_children')] %>%
    mutate(hh_child_adultval = hh_children/2) %>% # no. of children in adult value
    rowwise() %>%
    mutate(hh_adults = sum(c(hh_men, hh_women, hh_myoung, hh_fyoung, hh_child_adultval), na.rm = T))
  
  ## Family of workers
  data_workers <- data[,c('key', 'ag_men', 'ag_women', 'ag_myoung', 'ag_fyoung', 'ag_children')]
  data_workers <- data_workers %>%
    left_join(Area_total, by = 'key') %>%
    mutate(nag_children = ag_children/2) %>%
    rowwise() %>%
    mutate(fam_workers = sum(c(ag_men, ag_women, ag_myoung, ag_fyoung, nag_children), na.rm = T))
  
  # External workers
  ext_workers <- data[,c('key', 'num_extworkers_year', 'wage_year', 'num_extworkers_season', 'days_ext', 'wage_season')]
  
  ext_workers <- ext_workers %>%
    mutate(num_worker_fseason = num_extworkers_season*days_ext/300) %>% # Assuming 300 workingdays is a full year
    rowwise() %>%
    mutate(ext_workers = sum(c(num_worker_fseason, num_extworkers_year), na.rm = T)) %>%
    mutate(wage = sum(c(wage_year, wage_season), na.rm = T))
  
  data_workers <- data_workers %>%
    left_join(ext_workers, by = 'key') %>%
    rowwise() %>%
    mutate(num_workers = sum(c(fam_workers, ext_workers), na.rm = T))
```

To **cname_label** the names of the different crops, the list **other_crop** is added, since it contains all the alternative crops which manually have to be added, since they aren't in the TAPE list of crops yet. **cpg** describes the price of the crop at the gate (price when the crop leaves the farmers possession). The data is grouped by the different crops (**cname_label**) and the mean of the price at the gate is taken and defined as **cpg_median**. **cpg_median** is there to correct for too high, too low or values with wrong units. If **cpg** is suspiciously wrong **cpg_corr** is given the value of **cpg_median**, in all other cases it has the value of **cpg**. To get the total production of the farm (**crop_prod**) [in money] the the total production (**cprod**) [in kg] is multiplied by **cpg_corr**. For **crop_sales** the quantity sold(**cqsold**) is multiplied by **cpg_corr**.

```{r}
## Crop productivity
  c1 <- data_Crops
  
  # Make a check for price at the gate (can't be 0 or too low)
  cpg <- c1 %>%
    select(c('cname_label', 'other_crop', 'cpg_per_kg')) %>%
    mutate(cname_label = ifelse(cname_label == 'Other', other_crop, cname_label)) %>%
    group_by(cname_label) %>%
    summarise_at(vars(cpg_per_kg), median, na.rm = T) %>%
    rename(cpg_kg_median = cpg_per_kg)
  
  c1 <- c1 %>%
    left_join(cpg, by = 'cname_label') %>%
    # corrections for cpg if = 0 or NA or too low
    mutate(cpg_kg_corr = ifelse(cpg_per_kg == 0, cpg_kg_median, cpg_per_kg)) %>% 
    mutate(cpg_kg_corr = ifelse(is.na(cpg_per_kg), cpg_kg_median, cpg_per_kg)) %>%
    mutate(cpg_kg_corr = ifelse(cpg_per_kg/cpg_kg_median < 0.1, cpg_kg_median, cpg_per_kg)) %>%
    mutate(cpg_kg_corr = ifelse(cpg_per_kg/cpg_kg_median > 10, cpg_kg_median, cpg_per_kg)) %>%
    mutate(cpg_kg_corr = ifelse(is.na(cpg_kg_corr), cpg_per_kg, cpg_kg_corr)) 
  rm(cpg)
  
  c1 <- c1 %>%
    mutate(crop_prodval = cprod_kg * cpg_kg_corr,
           crop_sales = cqsold_kg * cpg_kg_corr,
           crop_giftcost = cgift_kg * cpg_kg_corr,
           crop_consval = (cprod_kg - cqsold_kg - cgift_kg) * cpg_kg_corr) %>%
    mutate(crop_consval = ifelse(crop_consval < 0, 0, crop_consval)) %>%
    group_by(key) %>%
    mutate(crop_prodval = sum(crop_prodval, na.rm = TRUE),
           crop_sales = sum(crop_sales, na.rm = TRUE),
           crop_giftcost = sum(crop_giftcost, na.rm = TRUE),
           crop_consval = sum(crop_consval, na.rm = TRUE)) %>%
    select(key,crop_prodval, crop_sales, crop_giftcost, crop_consval) %>% 
    distinct()
```

The same is done with forest products (just without the price correction). The Price at the gate is here called **cfppg** the total production **cfpprod** and the quantity sold **cfpqsold**.

```{r}
## Crops and forest products productivity
  cfp <- data_Crop_Products 
  
  # Make a check for price at the gate (can't be 0 or too low)
  cfppg <- cfp %>%
    select(c('cfp_label', 'cfpname_other', 'cfppg')) %>%
    mutate(cfp_label = ifelse(cfp_label %in% c('Other', 'Other 1', 'Other 2', 'Other 3'), cfpname_other, cfp_label)) %>%
    group_by(cfp_label) %>%
    summarise_at(vars(cfppg), median, na.rm = T) %>%
    rename(cfppg_median = cfppg)
  
  cfp <- cfp %>%
    left_join(cfppg, by = 'cfp_label') %>%
    # corrections for cfppg if == 0 or NA or too low/high
    mutate(cfppg_corr = ifelse(cfppg == 0, cfppg_median, cfppg),
           cfppg_corr = ifelse(is.na(cfppg), cfppg_median, cfppg),
           cfppg_corr = ifelse(cfppg/cfppg_median < 0.1, cfppg_median, cfppg),
           cfppg_corr = ifelse(cfppg/cfppg_median > 10, cfppg_median, cfppg),
           cfppg_corr = ifelse(is.na(cfppg_corr), cfppg, cfppg_corr))
  rm(cfppg)
    
  cfp <- cfp %>%
    mutate(cfp_prodval = cfpprod * cfppg_corr,
           cfp_sales = cfpqsold * cfppg_corr,
           cfp_giftcost = cfpgift * cfppg_corr,
           cfp_consval = (cfpprod - cfpqsold -cfpgift) * cfppg_corr) %>%
    mutate(cfp_consval = ifelse(cfp_consval < 0, 0, cfp_consval)) %>%
    group_by(key) %>%
    mutate(cfp_prodval = sum(cfp_prodval, na.rm = T),
           cfp_sales = sum(cfp_sales, na.rm = T),
           cfp_giftcost = sum(cfp_giftcost, na.rm = T),
           cfp_consval = sum(cfp_consval, na.rm = T)) %>%
    select(key, cfp_prodval, cfp_sales, cfp_giftcost, cfp_consval) %>%
    distinct()
```

The same is also done for animal productivity where the price at the gate is called **apg** and **aname** the name of the animal and **aname_other** the list of names that aren't in TAPE yet.**apg_median** is used to calculate the corrected price **apg_corr**\* .

```{r}
## Animal productivity
  a1 <- data_Animals
  
  # Make a check for price at the gate (can't be 0 or too low)
  apg <- a1 %>%
    select(c('an_label', 'aname_other', 'apg')) %>%
    mutate(an_label = ifelse(an_label %in% c('Other', 'Other 1', 'Other 2', 'Other 3'), aname_other, an_label)) %>%
    group_by(an_label) %>%
    summarise_at(vars(apg), median, na.rm = T) %>%
    rename(apg_median = apg)
  
  a1 <- a1 %>%
    left_join(apg, by = 'an_label') %>%
    # corrections for cpg if = 0 or NA or too low/high
    mutate(apg_corr = ifelse(apg == 0, apg_median, apg)) %>% 
    mutate(apg_corr = ifelse(is.na(apg), apg_median, apg)) %>%
    mutate(apg_corr = ifelse(apg/apg_median < 0.1, apg_median, apg)) %>%
    mutate(apg_corr = ifelse(apg/apg_median > 10, apg_median, apg)) %>%
    mutate(apg_corr = ifelse(is.na(apg_corr), apg, apg_corr)) 
  rm(apg)
  
  a1 <- a1 %>%
    mutate(anim_prodval = arais * apg_corr,
           anim_sales = aqsold * apg_corr,
           anim_giftcost = aqgift * apg_corr,
           anim_consval = (arais - aqsold - aqgift) * apg_corr) %>%
    mutate(anim_consval = ifelse(anim_consval < 0, 0, anim_consval)) %>%
    group_by(key) %>%
    mutate(anim_prodval = sum(anim_prodval, na.rm = T),
           anim_sales = sum(anim_sales, na.rm = T),
           anim_giftcost = sum(anim_giftcost, na.rm = T),
           anim_consval = sum(anim_consval, na.rm = T),
           feedexp = sum(feedexp, na.rm = T),
           vetexp = sum(vetexp, na.rm = T)) %>%
    select(key, anim_prodval, anim_sales, anim_giftcost, anim_consval, feedexp, vetexp) %>%
    distinct()
```

Animal Products repeat the same calculation as for e.g. crops. **apname** is the name of the product, **apname_other** of products that are categorized and **apppg** is the price at the gate. **anpr_prod** is the total production and **anpr_sales** are the total sales.

```{r}
## Animal Products Productivity
  ap <- data_Animal_Products
  
  # Make a check for price at the gate (can't be 0 or too low)
  appg <- ap %>%
    select(c('ap_label', 'apname_other', 'appg')) %>%
    mutate(ap_label = ifelse(ap_label %in% c('Ohter', 'Other 1', 'Other 2', 'Other 3'), apname_other, ap_label)) %>%
    group_by(ap_label) %>%
    summarise_at(vars(appg), median, na.rm = T) %>%
    rename(appg_median = appg)
  
  ap <- ap %>%
    left_join(appg, by = 'ap_label') %>%
    # corrections for cpg if = 0 or NA or too low
    mutate(appg_corr = ifelse(appg == 0, appg_median, appg)) %>% 
    mutate(appg_corr = ifelse(is.na(appg), appg_median, appg)) %>%
    mutate(appg_corr = ifelse(appg/appg_median < 0.1, appg_median, appg)) %>%
    mutate(appg_corr = ifelse(appg/appg_median > 10, appg_median, appg)) %>%
    mutate(appg_corr = ifelse(is.na(appg_corr), appg, appg_corr)) 
  rm(appg)
  
  ap <- ap %>%
    mutate(anpr_prodval = approd * appg_corr,
           anpr_sales = apqsold * appg_corr,
           anpr_giftcost = apgift*appg_corr,
           anpr_consval = (approd - apqsold - apgift) * appg_corr) %>%
    mutate(anpr_consval = ifelse(anpr_consval < 0, 0, anpr_consval)) %>%
    group_by(key) %>%
    mutate(anpr_prodval = sum(anpr_prodval, na.rm = TRUE),
           anpr_sales = sum(anpr_sales, na.rm = TRUE),
           anpr_giftcost = sum(anpr_giftcost, na.rm = TRUE),
           anpr_consval = sum(anpr_consval, na.rm = TRUE)) %>%
    select(key, anpr_prodval, anpr_sales, anpr_giftcost, anpr_consval) %>% 
    distinct()
```

All the data is then gathered together in a data frame. The **total_output** is then defined as the sum of **crop_prodval, cfp_prodval, anim_prodval** and **anpr_prodval**.

```{r}
## Productivity
  Economy <- c1 %>%
    left_join(cfp, by = 'key') %>%
    left_join(a1, by = 'key') %>%
    select(-c(feedexp, vetexp)) %>%
    left_join(ap, by = 'key') %>%
    rowwise() %>%
    mutate(total_output = sum(c(crop_prodval, cfp_prodval, anim_prodval, anpr_prodval), na.rm = T))
  rm(c1, ap)
  
```

The selected data covers all the expenditures for the farm, except expenses for food. The Variable **days_ext** is the sum of all the days external workers have worked on the farm and **wage** is their total wage.

```{r}
## Subsidies, Cost of Inputs, Taxes, interest on loans, cost of renting land
  Expenditures <- data %>%
    select(c('key', 'rentcost'), ends_with('exp')) %>%
    left_join(data_workers, by = 'key') %>%
    left_join(hh, by = 'key') %>%
    left_join(a1[,c('key', 'vetexp', 'feedexp')], by = 'key') %>%
    mutate(food_exp_capita = foodexp/hh_adults) %>%
    rowwise() %>%
    mutate(input_exp = sum(c(seedsexp, fertexp, cp_exp, op_exp), na.rm = T),
              fuel_energy_transp_exp = sum(c(fuelexp, enerexp, transpexp, machexp), na.rm = T),
              livestock_expenditures = sum(c(vetexp, livexp, feedexp), na.rm = T),
              finance_exp = sum(c(rentcost), na.rm = T), # subs, taxes & inter not included anymore
              total_expenditures = sum(c(foodexp, input_exp, fuel_energy_transp_exp, wage, livestock_expenditures, finance_exp), na.rm = T)) %>%
    mutate(share_foodexp = (foodexp/total_expenditures)*100)
  
  Economy <- Economy %>%
    left_join(Expenditures)
```

The Depreciation of the machines is calculated by **init_v** (initial value) which is the product of the number of owned machines and their price. From **init_v** the residual value **res_v** is calculated as 10% of the initial value. The **depreciation** is then calculated with two additional variables **myused** , the number of years the machinery has been used and **myplan**, the remaining useful life of this machinery. The total **depreciation** is then calculated for every farm.

```{r}
 ## Depreciation
  machine <- data_Machines
  
  machine <- machine %>%
    mutate(init_v = mowned * mprice,
           res_v = (init_v/100)*10,
           depreciation = (init_v - res_v)/(myused/(myused+myplan))) # change of the formula
  
  machine <- machine %>%
    group_by(key) %>%
    mutate(depreciation = sum(depreciation, na.rm = T)) %>%
    select(key, depreciation) %>%
    distinct()
  
  activities <- data_Activities %>%
    group_by(key) %>%
    summarise_at(vars(acrev), sum, na.rm = T)
  
  Economy <- Economy %>%
    left_join(machine, by = 'key') %>%
    left_join(activities, by = 'key') %>%
    mutate(depreciation = ifelse(is.na(depreciation), 0, depreciation)) %>%
    rowwise() %>%
    mutate(farm_revenue = sum(crop_sales, cfp_sales, anim_sales, anpr_sales, na.rm = T)) 
  
```

**net_revenue** is calculated from the sum of all the sales minus the expenses, depreciation and wage. Further economic variables are calculated, such as **value_added**. **ValueAdded** is calculated by the **total_output**, **cost_of_inputs** and **depreciation**. The data frame Economy is then returned as an output.

```{r}
Economy <- Economy %>%
    rowwise() %>%
    mutate(netrev = sum(c(farm_sales, acrev, -seedsexp, -fertexp, -feedexp, -vetexp, -machexp, -fuelexp, -enerexp, -transpexp, -cp_exp, -op_exp, -depreciation, -wage), na.rm = T),
           value_added = sum(c(total_output, acrev, -seedsexp, -fertexp, -feedexp, -vetexp, -machexp, -fuelexp, -enerexp, -transpexp, -cp_exp, -op_exp, -depreciation), na.rm = T)) %>%
    mutate(netrev_pcapita = netrev/hh_adults,
           value_added_pcapita = value_added/hh_adults,
           value_added_ha = value_added/area_total,
           value_added_gvp = value_added/total_output,
           value_added_gvp = ifelse(value_added_gvp < 0 & total_output < 0, -1*value_added_gvp, value_added_gvp), # rule of inequality and division by negative numbers
           # International Poverty line 2.15 USD
           inc_person_day = (farm_sales + acrev)/hh_adults/365)
  
```
